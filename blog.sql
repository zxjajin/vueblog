/*
SQLyog Ultimate v10.00 Beta1
MySQL - 8.0.25 : Database - vueblog
*********************************************************************
*/

/*!40101 SET NAMES utf8 */;

/*!40101 SET SQL_MODE=''*/;

/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;
CREATE DATABASE /*!32312 IF NOT EXISTS*/`vueblog` /*!40100 DEFAULT CHARACTER SET utf8 */ /*!80016 DEFAULT ENCRYPTION='N' */;

USE `vueblog`;

/*Table structure for table `m_blog` */

DROP TABLE IF EXISTS `m_blog`;

CREATE TABLE `m_blog` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `user_id` bigint NOT NULL,
  `title` varchar(255) NOT NULL,
  `description` varchar(255) NOT NULL,
  `content` longtext,
  `created` datetime NOT NULL ON UPDATE CURRENT_TIMESTAMP,
  `status` tinyint DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `m_blog_id_index` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=27 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;

/*Data for the table `m_blog` */

insert  into `m_blog`(`id`,`user_id`,`title`,`description`,`content`,`created`,`status`) values (1,1,'生活就像海洋，只有意志坚强的人才能到达彼岸','这里是摘要哈哈哈','内容？？？','2020-05-21 22:08:42',0),(2,1,'最值得学习的博客项目eblog','eblog是一个基于Springboot2.1.2开发的博客学习项目，为了让项目融合更多的知识点，达到学习目的，编写了详细的从0到1开发文档。主要学习包括：自定义Freemarker标签，使用shiro+redis完成了会话共享，redis的zset结构完成本周热议排行榜，t-io+websocket完成即时消息通知和群聊，rabbitmq+elasticsearch完成博客内容搜索引擎等。值得学习的地方很多！','**推荐阅读：**\r\n\r\n[分享一套SpringBoot开发博客系统源码，以及完整开发文档！速度保存！](https://mp.weixin.qq.com/s/jz6e977xP-OyaAKNjNca8w)\r\n\r\n[Github上最值得学习的100个Java开源项目，涵盖各种技术栈！](https://mp.weixin.qq.com/s/N-U0TaEUXnBFfBsmt_OESQ)\r\n\r\n[2020年最新的常问企业面试题大全以及答案](https://mp.weixin.qq.com/s/lR5LC5GnD2Gs59ecV5R0XA)','2020-05-28 09:36:38',0),(7,1,'你真的会写单例模式吗?','单例模式可能是代码最少的模式了，但是少不一定意味着简单，想要用好、用对单例模式，还真得费一番脑筋。本文对 Java 中常见的单例模式写法做了一个总结，如有错漏之处，恳请读者指正。','> 作者：吃桔子的攻城狮 来源：http://www.tekbroaden.com/singleton-java.html\n\n\n单例模式可能是代码最少的模式了，但是少不一定意味着简单，想要用好、用对单例模式，还真得费一番脑筋。本文对 Java 中常见的单例模式写法做了一个总结，如有错漏之处，恳请读者指正。\n\n饿汉法\n===\n\n顾名思义，饿汉法就是在第一次引用该类的时候就创建对象实例，而不管实际是否需要创建。代码如下：\n\n```\npublic class Singleton {  \n    private static Singleton = new Singleton();\n    private Singleton() {}\n    public static getSignleton(){\n        return singleton;\n    }\n}\n\n```\n\n这样做的好处是编写简单，但是无法做到延迟创建对象。但是我们很多时候都希望对象可以尽可能地延迟加载，从而减小负载，所以就需要下面的懒汉法：\n','2020-05-22 00:42:44',0),(9,1,'真正理解Mysql的四种隔离级别@','事务是应用程序中一系列严密的操作，所有操作必须成功完成，否则在每个操作中所作的所有更改都会被撤消。也就是事务具有原子性，一个事务中的一系列的操作要么全部成功，要么一个都不做。\n\n事务的结束有两种，当事务中的所以步骤全部成功执行时，事务提交。如果其中一个步骤失败，将发生回滚操作，撤消撤消之前到事务开始时的所以操作。','### 什么是事务  \n\n> 事务是应用程序中一系列严密的操作，所有操作必须成功完成，否则在每个操作中所作的所有更改都会被撤消。也就是事务具有原子性，一个事务中的一系列的操作要么全部成功，要么一个都不做。\n> \n> 事务的结束有两种，当事务中的所以步骤全部成功执行时，事务提交。如果其中一个步骤失败，将发生回滚操作，撤消撤消之前到事务开始时的所以操作。\n\n**事务的 ACID**\n\n事务具有四个特征：原子性（ Atomicity ）、一致性（ Consistency ）、隔离性（ Isolation ）和持续性（ Durability ）。这四个特性简称为 ACID 特性。\n\n> 1 、原子性。事务是数据库的逻辑工作单位，事务中包含的各操作要么都做，要么都不做\n> \n> 2 、一致性。事 务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。因此当数据库只包含成功事务提交的结果时，就说数据库处于一致性状态。如果数据库系统 运行中发生故障，有些事务尚未完成就被迫中断，这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态，或者说是 不一致的状态。','2020-05-22 22:04:46',0),(10,1,'博客项目eblog讲解视频上线啦，长达17个小时！！','1. 慕课网免费资源好久都没更新了，新教程大都付费\n2. B站上的视频繁多，通过收藏和弹幕数量通常很容易判断出视频是否优质\n3. 讲真，B站的弹幕文化，让我觉得，我不是一个在学习，自古人才出评论。哈哈哈\n4. B站视频通常广告少，up主的用心录制，通常只为了你关注他','ok，再回到我们的eblog项目，源码、文档、视频我都开源出来了。来些基本操作：github上给个star，B站视频给个三连支持咧。\n\neblog源码：https://github.com/MarkerHub/eblog\n\n点击这里：[10+篇完整开发文档](https://mp.weixin.qq.com/mp/homepage?__biz=MzIwODkzOTc1MQ==&hid=1&sn=8e512316c3dfe140e636d0c996951166)\n\n![](//image-1300566513.cos.ap-guangzhou.myqcloud.com/upload/images/20200508/c290d945b7d24c79b172759bdb5b94e0.png)\n\n视频讲解：（记得关注我噢！）\n\nhttps://www.bilibili.com/video/BV1ri4y1x71A\n\n![](//image-1300566513.cos.ap-guangzhou.myqcloud.com/upload/images/20200508/983b5abc1c934360a1a1362347a275f7.png)\n\n项目其实还很多bug的，哈哈，我还需要进行二次迭代，到时候再发迭代文档出来。\n\n关注下我的B站，作为一个自媒体的自由职业者，没有什么比涨粉更让我开心的了，嘻嘻。\n\n近期即将推出的视频教程：\n\n1. 搭建脚手架，前后端分离首秀\n2. Shiro入门到精通教程\n3. SpringBoot2.2.6最新入门教程','2020-05-22 22:05:49',0),(21,2,'Git常用命令','实际开发中Git的使用','### Git常用命令\n\n|                  命令名称                  |                           作用                           |\n| :----------------------------------------: | :------------------------------------------------------: |\n|    git config --global user.name 用户名    |                       设置用户签名                       |\n|    git config --global user.email 邮箱     |                       设置用户签名                       |\n|              git init（重点）              |                       初始化本地库                       |\n|             git status（重点）             |                      查看本地库状态                      |\n|           git add 文件名（重点）           |                       添加到暂存区                       |\n|           git rm --cached 文件名           |                      删除暂存区文件                      |\n|  git commit -m \"日志信息\" 文件名（重点）   |                       提交到本地库                       |\n|             git reflog（重点）             |                       查看历史记录                       |\n|                  git log                   |                     查看版本详细信息                     |\n|      get reset --hard 版本号（重点）       |                         版本穿梭                         |\n|             git branch 分支名              |                         创建分支                         |\n|               git branch -v                |                         查看分支                         |\n|            git checkout 分支名             |                         切换分支                         |\n|       git branch -m oldName newName        |                       修改分支名称                       |\n|            Git branch -d 分支名            |                         删除分支                         |\n|          git merge 分支名（重点）          |               把指定的分支合并到当前分支上               |\n|               git remote -v                |                 查看当前所有远程地址别名                 |\n|        git remote add 别名 远程地址        |                          起别名                          |\n|         git push 别名 分支（重点）         |              推送本地分支上的内容到远程仓库              |\n|         git clone 远程地址（重点）         |                将远程仓库的内容克隆到本地                |\n| git pull 远程库地址别名 远程分支名（重点） | 将远程仓库对应分支最新内容拉下来后与当前本地分支直接合并 |\n|                                            |                                                          |','2023-05-14 05:05:01',0),(22,2,'JDBC核心技术','关于JDBC你了解多少','## 第1章：JDBC概述\n\n### 1.1 数据的持久化\n\n- 持久化(persistence)：**把数据保存到可掉电式存储设备中以供之后使用**。大多数情况下，特别是企业级应用，**数据持久化意味着将内存中的数据保存到硬盘**上加以”固化”**，而持久化的实现过程大多通过各种关系数据库来完成**。\n\n- 持久化的主要应用是将内存中的数据存储在关系型数据库中，当然也可以存储在磁盘文件、XML数据文件中。\n\n\n\n### 1.2 Java中的数据存储技术\n\n- 在Java中，数据库存取技术可分为如下几类：\n  - **JDBC**直接访问数据库\n  - JDO (Java Data Object )技术\n\n  - **第三方O/R工具**，如Hibernate, Mybatis 等\n\n- JDBC是java访问数据库的基石，JDO、Hibernate、MyBatis等只是更好的封装了JDBC。\n\n### 1.3 JDBC介绍\n\n- JDBC(Java Database Connectivity)是一个**独立于特定数据库管理系统、通用的SQL数据库存取和操作的公共接口**（一组API），定义了用来访问数据库的标准Java类库，（**java.sql,javax.sql**）使用这些类库可以以一种**标准**的方法、方便地访问数据库资源。\n- JDBC为访问不同的数据库提供了一种**统一的途径**，为开发者屏蔽了一些细节问题。\n- JDBC的目标是使Java程序员使用JDBC可以连接任何**提供了JDBC驱动程序**的数据库系统，这样就使得程序员无需对特定的数据库系统的特点有过多的了解，从而大大简化和加快了开发过程。\n- 如果没有JDBC，那么Java程序访问数据库时是这样的：\n\n![1555575760234](尚硅谷_宋红康_JDBC.assets/1555575760234.png)\n\n***\n\n- 有了JDBC，Java程序访问数据库时是这样的：\n\n\n![1555575981203](尚硅谷_宋红康_JDBC.assets/1555575981203.png)\n\n***\n\n- 总结如下：\n\n![1566741692804](尚硅谷_宋红康_JDBC.assets/1566741692804.png)\n\n### 1.4 JDBC体系结构\n\n- JDBC接口（API）包括两个层次：\n  - **面向应用的API**：Java API，抽象接口，供应用程序开发人员使用（连接数据库，执行SQL语句，获得结果）。\n  - **面向数据库的API**：Java Driver API，供开发商开发数据库驱动程序用。\n\n> **JDBC是sun公司提供一套用于数据库操作的接口，java程序员只需要面向这套接口编程即可。**\n>\n> **不同的数据库厂商，需要针对这套接口，提供不同实现。不同的实现的集合，即为不同数据库的驱动。																————面向接口编程**\n\n### 1.5 JDBC程序编写步骤\n\n![1565969323908](尚硅谷_宋红康_JDBC.assets/1565969323908.png)\n\n> 补充：ODBC(**Open Database Connectivity**，开放式数据库连接)，是微软在Windows平台下推出的。使用者在程序中只需要调用ODBC API，由 ODBC 驱动程序将调用转换成为对特定的数据库的调用请求。\n\n## 第2章：获取数据库连接\n\n### 2.1 要素一：Driver接口实现类\n\n#### 2.1.1 Driver接口介绍\n\n- java.sql.Driver 接口是所有 JDBC 驱动程序需要实现的接口。这个接口是提供给数据库厂商使用的，不同数据库厂商提供不同的实现。\n\n- 在程序中不需要直接去访问实现了 Driver 接口的类，而是由驱动程序管理器类(java.sql.DriverManager)去调用这些Driver实现。\n  - Oracle的驱动：**oracle.jdbc.driver.OracleDriver**\n  - mySql的驱动： **com.mysql.jdbc.Driver**\n\n\n\n- 将上述jar包拷贝到Java工程的一个目录中，习惯上新建一个lib文件夹。\n\n\n\n在驱动jar上右键-->Build Path-->Add to Build Path\n\n\n\n注意：如果是Dynamic Web Project（动态的web项目）话，则是把驱动jar放到WebContent（有的开发工具叫WebRoot）目录中的WEB-INF目录中的lib目录下即可\n\n\n\n#### 2.1.2 加载与注册JDBC驱动\n\n- 加载驱动：加载 JDBC 驱动需调用 Class 类的静态方法 forName()，向其传递要加载的 JDBC 驱动的类名\n\n  - **Class.forName(“com.mysql.jdbc.Driver”);**\n\n- 注册驱动：DriverManager 类是驱动程序管理器类，负责管理驱动程序\n\n  - **使用DriverManager.registerDriver(com.mysql.jdbc.Driver)来注册驱动**\n\n  - 通常不用显式调用 DriverManager 类的 registerDriver() 方法来注册驱动程序类的实例，因为 Driver 接口的驱动程序类**都**包含了静态代码块，在这个静态代码块中，会调用 DriverManager.registerDriver() 方法来注册自身的一个实例。下图是MySQL的Driver实现类的源码：\n\n    ![1566136831283](尚硅谷_宋红康_JDBC.assets/1566136831283.png)\n\n### 2.2 要素二：URL\n\n- JDBC URL 用于标识一个被注册的驱动程序，驱动程序管理器通过这个 URL 选择正确的驱动程序，从而建立到数据库的连接。\n\n- JDBC URL的标准由三部分组成，各部分间用冒号分隔。 \n\n  - **jdbc:子协议:子名称**\n  - **协议**：JDBC URL中的协议总是jdbc \n  - **子协议**：子协议用于标识一个数据库驱动程序\n  - **子名称**：一种标识数据库的方法。子名称可以依不同的子协议而变化，用子名称的目的是为了**定位数据库**提供足够的信息。包含**主机名**(对应服务端的ip地址)**，端口号，数据库名**\n\n- 举例：\n\n\n\n- **几种常用数据库的 JDBC URL**\n\n  - MySQL的连接URL编写方式：\n\n    - jdbc:mysql://主机名称:mysql服务端口号/数据库名称?参数=值&参数=值\n    - jdbc:mysql://localhost:3306/atguigu\n    - jdbc:mysql://localhost:3306/atguigu**?useUnicode=true&characterEncoding=utf8**（如果JDBC程序与服务器端的字符集不一致，会导致乱码，那么可以通过参数指定服务器端的字符集）\n    - jdbc:mysql://localhost:3306/atguigu?user=root&password=123456\n\n  - Oracle 9i的连接URL编写方式：\n\n    - jdbc:oracle:thin:@主机名称:oracle服务端口号:数据库名称\n    - jdbc:oracle:thin:@localhost:1521:atguigu\n\n  - SQLServer的连接URL编写方式：\n\n    - jdbc:sqlserver://主机名称:sqlserver服务端口号:DatabaseName=数据库名称\n\n    - jdbc:sqlserver://localhost:1433:DatabaseName=atguigu\n\n### 2.3 要素三：用户名和密码\n\n- user,password可以用“属性名=属性值”方式告诉数据库\n- 可以调用 DriverManager 类的 getConnection() 方法建立到数据库的连接\n\n### 2.4 数据库连接方式举例\n\n#### 2.4.1 连接方式一\n\n```java\n	@Test\n    public void testConnection1() {\n        try {\n            //1.提供java.sql.Driver接口实现类的对象\n            Driver driver = null;\n            driver = new com.mysql.jdbc.Driver();\n\n            //2.提供url，指明具体操作的数据\n            String url = \"jdbc:mysql://localhost:3306/test\";\n\n            //3.提供Properties的对象，指明用户名和密码\n            Properties info = new Properties();\n            info.setProperty(\"user\", \"root\");\n            info.setProperty(\"password\", \"abc123\");\n\n            //4.调用driver的connect()，获取连接\n            Connection conn = driver.connect(url, info);\n            System.out.println(conn);\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n```\n\n> 说明：上述代码中显式出现了第三方数据库的API\n\n#### 2.4.2 连接方式二\n\n```java\n	@Test\n    public void testConnection2() {\n        try {\n            //1.实例化Driver\n            String className = \"com.mysql.jdbc.Driver\";\n            Class clazz = Class.forName(className);\n            Driver driver = (Driver) clazz.newInstance();\n\n            //2.提供url，指明具体操作的数据\n            String url = \"jdbc:mysql://localhost:3306/test\";\n\n            //3.提供Properties的对象，指明用户名和密码\n            Properties info = new Properties();\n            info.setProperty(\"user\", \"root\");\n            info.setProperty(\"password\", \"abc123\");\n\n            //4.调用driver的connect()，获取连接\n            Connection conn = driver.connect(url, info);\n            System.out.println(conn);\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n```\n\n> 说明：相较于方式一，这里使用反射实例化Driver，不在代码中体现第三方数据库的API。体现了面向接口编程思想。\n\n#### 2.4.3 连接方式三\n\n```java\n	@Test\n    public void testConnection3() {\n        try {\n            //1.数据库连接的4个基本要素：\n            String url = \"jdbc:mysql://localhost:3306/test\";\n            String user = \"root\";\n            String password = \"abc123\";\n            String driverName = \"com.mysql.jdbc.Driver\";\n\n            //2.实例化Driver\n            Class clazz = Class.forName(driverName);\n            Driver driver = (Driver) clazz.newInstance();\n            //3.注册驱动\n            DriverManager.registerDriver(driver);\n            //4.获取连接\n            Connection conn = DriverManager.getConnection(url, user, password);\n            System.out.println(conn);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n    }\n```\n\n> 说明：使用DriverManager实现数据库的连接。体会获取连接必要的4个基本要素。\n\n#### 2.4.4 连接方式四\n\n```java\n	@Test\n    public void testConnection4() {\n        try {\n            //1.数据库连接的4个基本要素：\n            String url = \"jdbc:mysql://localhost:3306/test\";\n            String user = \"root\";\n            String password = \"abc123\";\n            String driverName = \"com.mysql.jdbc.Driver\";\n\n            //2.加载驱动 （①实例化Driver ②注册驱动）\n            Class.forName(driverName);\n\n\n            //Driver driver = (Driver) clazz.newInstance();\n            //3.注册驱动\n            //DriverManager.registerDriver(driver);\n            /*\n            可以注释掉上述代码的原因，是因为在mysql的Driver类中声明有：\n            static {\n                try {\n                    DriverManager.registerDriver(new Driver());\n                } catch (SQLException var1) {\n                    throw new RuntimeException(\"Can\'t register driver!\");\n                }\n            }\n\n             */\n\n\n            //3.获取连接\n            Connection conn = DriverManager.getConnection(url, user, password);\n            System.out.println(conn);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n    }\n```\n\n> 说明：不必显式的注册驱动了。因为在DriverManager的源码中已经存在静态代码块，实现了驱动的注册。\n\n#### 2.4.5 连接方式五(最终版)\n\n```java\n	@Test\n    public  void testConnection5() throws Exception {\n    	//1.加载配置文件\n        InputStream is = ConnectionTest.class.getClassLoader().getResourceAsStream(\"jdbc.properties\");\n        Properties pros = new Properties();\n        pros.load(is);\n        \n        //2.读取配置信息\n        String user = pros.getProperty(\"user\");\n        String password = pros.getProperty(\"password\");\n        String url = pros.getProperty(\"url\");\n        String driverClass = pros.getProperty(\"driverClass\");\n\n        //3.加载驱动\n        Class.forName(driverClass);\n\n        //4.获取连接\n        Connection conn = DriverManager.getConnection(url,user,password);\n        System.out.println(conn);\n\n    }\n```\n\n其中，配置文件声明在工程的src目录下：【jdbc.properties】\n\n```properties\nuser=root\npassword=abc123\nurl=jdbc:mysql://localhost:3306/test\ndriverClass=com.mysql.jdbc.Driver\n```\n\n> 说明：使用配置文件的方式保存配置信息，在代码中加载配置文件\n>\n> **使用配置文件的好处：**\n>\n> ①实现了代码和数据的分离，如果需要修改配置信息，直接在配置文件中修改，不需要深入代码\n> ②如果修改了配置信息，省去重新编译的过程。\n\n## 第3章：使用PreparedStatement实现CRUD操作\n\n### 3.1 操作和访问数据库\n\n- 数据库连接被用于向数据库服务器发送命令和 SQL 语句，并接受数据库服务器返回的结果。其实一个数据库连接就是一个Socket连接。\n\n- 在 java.sql 包中有 3 个接口分别定义了对数据库的调用的不同方式：\n\n  - Statement：用于执行静态 SQL 语句并返回它所生成结果的对象。 \n  - PrepatedStatement：SQL 语句被预编译并存储在此对象中，可以使用此对象多次高效地执行该语句。\n  - CallableStatement：用于执行 SQL 存储过程\n\n  ![1566573842140](尚硅谷_宋红康_JDBC.assets/1566573842140.png)\n\n### 3.2 使用Statement操作数据表的弊端\n\n- 通过调用 Connection 对象的 createStatement() 方法创建该对象。该对象用于执行静态的 SQL 语句，并且返回执行结果。\n\n- Statement 接口中定义了下列方法用于执行 SQL 语句：\n\n  ```sql\n  int excuteUpdate(String sql)：执行更新操作INSERT、UPDATE、DELETE\n  ResultSet executeQuery(String sql)：执行查询操作SELECT\n  ```\n\n- 但是使用Statement操作数据表存在弊端：\n\n  - **问题一：存在拼串操作，繁琐**\n  - **问题二：存在SQL注入问题**\n\n- SQL 注入是利用某些系统没有对用户输入的数据进行充分的检查，而在用户输入数据中注入非法的 SQL 语句段或命令(如：SELECT user, password FROM user_table WHERE user=\'a\' OR 1 = \' AND password = \' OR \'1\' = \'1\') ，从而利用系统的 SQL 引擎完成恶意行为的做法。\n\n- 对于 Java 而言，要防范 SQL 注入，只要用 PreparedStatement(从Statement扩展而来) 取代 Statement 就可以了。\n\n- 代码演示：\n\n```java\npublic class StatementTest {\n\n	// 使用Statement的弊端：需要拼写sql语句，并且存在SQL注入的问题\n	@Test\n	public void testLogin() {\n		Scanner scan = new Scanner(System.in);\n\n		System.out.print(\"用户名：\");\n		String userName = scan.nextLine();\n		System.out.print(\"密   码：\");\n		String password = scan.nextLine();\n\n		// SELECT user,password FROM user_table WHERE USER = \'1\' or \' AND PASSWORD = \'=\'1\' or \'1\' = \'1\';\n		String sql = \"SELECT user,password FROM user_table WHERE USER = \'\" + userName + \"\' AND PASSWORD = \'\" + password\n				+ \"\'\";\n		User user = get(sql, User.class);\n		if (user != null) {\n			System.out.println(\"登陆成功!\");\n		} else {\n			System.out.println(\"用户名或密码错误！\");\n		}\n	}\n\n	// 使用Statement实现对数据表的查询操作\n	public <T> T get(String sql, Class<T> clazz) {\n		T t = null;\n\n		Connection conn = null;\n		Statement st = null;\n		ResultSet rs = null;\n		try {\n			// 1.加载配置文件\n			InputStream is = StatementTest.class.getClassLoader().getResourceAsStream(\"jdbc.properties\");\n			Properties pros = new Properties();\n			pros.load(is);\n\n			// 2.读取配置信息\n			String user = pros.getProperty(\"user\");\n			String password = pros.getProperty(\"password\");\n			String url = pros.getProperty(\"url\");\n			String driverClass = pros.getProperty(\"driverClass\");\n\n			// 3.加载驱动\n			Class.forName(driverClass);\n\n			// 4.获取连接\n			conn = DriverManager.getConnection(url, user, password);\n\n			st = conn.createStatement();\n\n			rs = st.executeQuery(sql);\n\n			// 获取结果集的元数据\n			ResultSetMetaData rsmd = rs.getMetaData();\n\n			// 获取结果集的列数\n			int columnCount = rsmd.getColumnCount();\n\n			if (rs.next()) {\n\n				t = clazz.newInstance();\n\n				for (int i = 0; i < columnCount; i++) {\n					// //1. 获取列的名称\n					// String columnName = rsmd.getColumnName(i+1);\n\n					// 1. 获取列的别名\n					String columnName = rsmd.getColumnLabel(i + 1);\n\n					// 2. 根据列名获取对应数据表中的数据\n					Object columnVal = rs.getObject(columnName);\n\n					// 3. 将数据表中得到的数据，封装进对象\n					Field field = clazz.getDeclaredField(columnName);\n					field.setAccessible(true);\n					field.set(t, columnVal);\n				}\n				return t;\n			}\n		} catch (Exception e) {\n			e.printStackTrace();\n		} finally {\n			// 关闭资源\n			if (rs != null) {\n				try {\n					rs.close();\n				} catch (SQLException e) {\n					e.printStackTrace();\n				}\n			}\n			if (st != null) {\n				try {\n					st.close();\n				} catch (SQLException e) {\n					e.printStackTrace();\n				}\n			}\n\n			if (conn != null) {\n				try {\n					conn.close();\n				} catch (SQLException e) {\n					e.printStackTrace();\n				}\n			}\n		}\n\n		return null;\n	}\n}\n```\n\n综上：\n\n![1566569819744](尚硅谷_宋红康_JDBC.assets/1566569819744.png)\n\n### 3.3 PreparedStatement的使用\n\n#### 3.3.1 PreparedStatement介绍\n\n- 可以通过调用 Connection 对象的 **preparedStatement(String sql)** 方法获取 PreparedStatement 对象\n\n- **PreparedStatement 接口是 Statement 的子接口，它表示一条预编译过的 SQL 语句**\n\n- PreparedStatement 对象所代表的 SQL 语句中的参数用问号(?)来表示，调用 PreparedStatement 对象的 setXxx() 方法来设置这些参数. setXxx() 方法有两个参数，第一个参数是要设置的 SQL 语句中的参数的索引(从 1 开始)，第二个是设置的 SQL 语句中的参数的值\n\n#### 3.3.2 PreparedStatement vs Statement\n\n- 代码的可读性和可维护性。\n\n- **PreparedStatement 能最大可能提高性能：**\n  - DBServer会对**预编译**语句提供性能优化。因为预编译语句有可能被重复调用，所以<u>语句在被DBServer的编译器编译后的执行代码被缓存下来，那么下次调用时只要是相同的预编译语句就不需要编译，只要将参数直接传入编译过的语句执行代码中就会得到执行。</u>\n  - 在statement语句中,即使是相同操作但因为数据内容不一样,所以整个语句本身不能匹配,没有缓存语句的意义.事实是没有数据库会对普通语句编译后的执行代码缓存。这样<u>每执行一次都要对传入的语句编译一次。</u>\n  - (语法检查，语义检查，翻译成二进制命令，缓存)\n\n- PreparedStatement 可以防止 SQL 注入 \n\n#### 3.3.3 Java与SQL对应数据类型转换表\n\n| Java类型           | SQL类型                  |\n| ------------------ | ------------------------ |\n| boolean            | BIT                      |\n| byte               | TINYINT                  |\n| short              | SMALLINT                 |\n| int                | INTEGER                  |\n| long               | BIGINT                   |\n| String             | CHAR,VARCHAR,LONGVARCHAR |\n| byte   array       | BINARY  ,    VAR BINARY  |\n| java.sql.Date      | DATE                     |\n| java.sql.Time      | TIME                     |\n| java.sql.Timestamp | TIMESTAMP                |\n\n#### 3.3.4 使用PreparedStatement实现增、删、改操作\n\n```java\n	//通用的增、删、改操作（体现一：增、删、改 ； 体现二：针对于不同的表）\n	public void update(String sql,Object ... args){\n		Connection conn = null;\n		PreparedStatement ps = null;\n		try {\n			//1.获取数据库的连接\n			conn = JDBCUtils.getConnection();\n			\n			//2.获取PreparedStatement的实例 (或：预编译sql语句)\n			ps = conn.prepareStatement(sql);\n			//3.填充占位符\n			for(int i = 0;i < args.length;i++){\n				ps.setObject(i + 1, args[i]);\n			}\n			\n			//4.执行sql语句\n			ps.execute();\n		} catch (Exception e) {\n			\n			e.printStackTrace();\n		}finally{\n			//5.关闭资源\n			JDBCUtils.closeResource(conn, ps);\n			\n		}\n	}\n```\n\n\n\n#### 3.3.5 使用PreparedStatement实现查询操作\n\n```java\n	// 通用的针对于不同表的查询:返回一个对象 (version 1.0)\n	public <T> T getInstance(Class<T> clazz, String sql, Object... args) {\n\n		Connection conn = null;\n		PreparedStatement ps = null;\n		ResultSet rs = null;\n		try {\n			// 1.获取数据库连接\n			conn = JDBCUtils.getConnection();\n\n			// 2.预编译sql语句，得到PreparedStatement对象\n			ps = conn.prepareStatement(sql);\n\n			// 3.填充占位符\n			for (int i = 0; i < args.length; i++) {\n				ps.setObject(i + 1, args[i]);\n			}\n\n			// 4.执行executeQuery(),得到结果集：ResultSet\n			rs = ps.executeQuery();\n\n			// 5.得到结果集的元数据：ResultSetMetaData\n			ResultSetMetaData rsmd = rs.getMetaData();\n\n			// 6.1通过ResultSetMetaData得到columnCount,columnLabel；通过ResultSet得到列值\n			int columnCount = rsmd.getColumnCount();\n			if (rs.next()) {\n				T t = clazz.newInstance();\n				for (int i = 0; i < columnCount; i++) {// 遍历每一个列\n\n					// 获取列值\n					Object columnVal = rs.getObject(i + 1);\n					// 获取列的别名:列的别名，使用类的属性名充当\n					String columnLabel = rsmd.getColumnLabel(i + 1);\n					// 6.2使用反射，给对象的相应属性赋值\n					Field field = clazz.getDeclaredField(columnLabel);\n					field.setAccessible(true);\n					field.set(t, columnVal);\n\n				}\n\n				return t;\n\n			}\n		} catch (Exception e) {\n\n			e.printStackTrace();\n		} finally {\n			// 7.关闭资源\n			JDBCUtils.closeResource(conn, ps, rs);\n		}\n\n		return null;\n\n	}\n```\n\n> 说明：使用PreparedStatement实现的查询操作可以替换Statement实现的查询操作，解决Statement拼串和SQL注入问题。\n\n### 3.4 ResultSet与ResultSetMetaData\n\n#### 3.4.1 ResultSet\n\n- 查询需要调用PreparedStatement 的 executeQuery() 方法，查询结果是一个ResultSet 对象\n\n- ResultSet 对象以逻辑表格的形式封装了执行数据库操作的结果集，ResultSet 接口由数据库厂商提供实现\n\n- ResultSet 返回的实际上就是一张数据表。有一个指针指向数据表的第一条记录的前面。\n\n- ResultSet 对象维护了一个指向当前数据行的**游标**，初始的时候，游标在第一行之前，可以通过 ResultSet 对象的 next() 方法移动到下一行。调用 next()方法检测下一行是否有效。若有效，该方法返回 true，且指针下移。相当于Iterator对象的 hasNext() 和 next() 方法的结合体。\n\n- 当指针指向一行时, 可以通过调用 getXxx(int index) 或 getXxx(int columnName) 获取每一列的值。\n\n  - 例如: getInt(1), getString(\"name\")\n  - **注意：Java与数据库交互涉及到的相关Java API中的索引都从1开始。**\n\n- ResultSet 接口的常用方法：\n\n  - boolean next()\n\n  - getString()\n  - …\n\n  ![1555580152530](尚硅谷_宋红康_JDBC.assets/1555580152530.png)\n\n#### 3.4.2 ResultSetMetaData\n\n- 可用于获取关于 ResultSet 对象中列的类型和属性信息的对象\n\n- ResultSetMetaData meta = rs.getMetaData();\n  - **getColumnName**(int column)：获取指定列的名称\n  - **getColumnLabel**(int column)：获取指定列的别名\n  - **getColumnCount**()：返回当前 ResultSet 对象中的列数。 \n\n  - getColumnTypeName(int column)：检索指定列的数据库特定的类型名称。 \n  - getColumnDisplaySize(int column)：指示指定列的最大标准宽度，以字符为单位。 \n  - **isNullable**(int column)：指示指定列中的值是否可以为 null。 \n\n  - isAutoIncrement(int column)：指示是否自动为指定列进行编号，这样这些列仍然是只读的。 \n\n![1555579494691](尚硅谷_宋红康_JDBC.assets/1555579494691.png)\n\n**问题1：得到结果集后, 如何知道该结果集中有哪些列 ？ 列名是什么？**\n\n​     需要使用一个描述 ResultSet 的对象， 即 ResultSetMetaData\n\n**问题2：关于ResultSetMetaData**\n\n1. **如何获取 ResultSetMetaData**： 调用 ResultSet 的 getMetaData() 方法即可\n2. **获取 ResultSet 中有多少列**：调用 ResultSetMetaData 的 getColumnCount() 方法\n3. **获取 ResultSet 每一列的列的别名是什么**：调用 ResultSetMetaData 的getColumnLabel() 方法\n\n![1555579816884](尚硅谷_宋红康_JDBC.assets/1555579816884.png)\n\n### 3.5 资源的释放\n\n- 释放ResultSet, Statement,Connection。\n- 数据库连接（Connection）是非常稀有的资源，用完后必须马上释放，如果Connection不能及时正确的关闭将导致系统宕机。Connection的使用原则是**尽量晚创建，尽量早的释放。**\n- 可以在finally中关闭，保证及时其他代码出现异常，资源也一定能被关闭。\n\n\n\n### 3.6 JDBC API小结\n\n- 两种思想\n\n  - 面向接口编程的思想\n\n  - ORM思想(object relational mapping)\n    - 一个数据表对应一个java类\n    - 表中的一条记录对应java类的一个对象\n    - 表中的一个字段对应java类的一个属性\n\n  > sql是需要结合列名和表的属性名来写。注意起别名。\n\n- 两种技术\n\n  - JDBC结果集的元数据：ResultSetMetaData\n    - 获取列数：getColumnCount()\n    - 获取列的别名：getColumnLabel()\n  - 通过反射，创建指定类的对象，获取指定的属性并赋值\n\n\n\n***\n\n## 章节练习\n\n**练习题1：从控制台向数据库的表customers中插入一条数据，表结构如下：**\n\n![1555580275036](尚硅谷_宋红康_JDBC.assets/1555580275036.png)\n\n\n\n**练习题2：创立数据库表 examstudent，表结构如下：**\n\n![1555580735377](尚硅谷_宋红康_JDBC.assets/1555580735377.png)\n\n向数据表中添加如下数据：\n\n![1555580763636](尚硅谷_宋红康_JDBC.assets/1555580763636.png)\n\n**代码实现1：插入一个新的student 信息**\n\n请输入考生的详细信息\n\nType: \nIDCard:\nExamCard:\nStudentName:\nLocation:\nGrade:\n\n信息录入成功!\n\n**代码实现2：在 eclipse中建立 java 程序：输入身份证号或准考证号可以查询到学生的基本信息。结果如下：**\n\n![1555580937490](尚硅谷_宋红康_JDBC.assets/1555580937490.png)\n\n**代码实现3：完成学生信息的删除功能**\n\n![1555580965019](尚硅谷_宋红康_JDBC.assets/1555580965019.png)\n\n***\n\n\n\n## 第4章 操作BLOB类型字段\n\n### 4.1 MySQL BLOB类型\n\n- MySQL中，BLOB是一个二进制大型对象，是一个可以存储大量数据的容器，它能容纳不同大小的数据。\n- 插入BLOB类型的数据必须使用PreparedStatement，因为BLOB类型的数据无法使用字符串拼接写的。\n\n- MySQL的四种BLOB类型(除了在存储的最大信息量上不同外，他们是等同的)\n\n![1555581069798](尚硅谷_宋红康_JDBC.assets/1555581069798.png)\n\n- 实际使用中根据需要存入的数据大小定义不同的BLOB类型。\n- 需要注意的是：如果存储的文件过大，数据库的性能会下降。\n- 如果在指定了相关的Blob类型以后，还报错：xxx too large，那么在mysql的安装目录下，找my.ini文件加上如下的配置参数： **max_allowed_packet=16M**。同时注意：修改了my.ini文件之后，需要重新启动mysql服务。\n\n### 4.2 向数据表中插入大数据类型\n\n```java\n//获取连接\nConnection conn = JDBCUtils.getConnection();\n		\nString sql = \"insert into customers(name,email,birth,photo)values(?,?,?,?)\";\nPreparedStatement ps = conn.prepareStatement(sql);\n\n// 填充占位符\nps.setString(1, \"徐海强\");\nps.setString(2, \"xhq@126.com\");\nps.setDate(3, new Date(new java.util.Date().getTime()));\n// 操作Blob类型的变量\nFileInputStream fis = new FileInputStream(\"xhq.png\");\nps.setBlob(4, fis);\n//执行\nps.execute();\n		\nfis.close();\nJDBCUtils.closeResource(conn, ps);\n\n```\n\n\n\n### 4.3 修改数据表中的Blob类型字段\n\n```java\nConnection conn = JDBCUtils.getConnection();\nString sql = \"update customers set photo = ? where id = ?\";\nPreparedStatement ps = conn.prepareStatement(sql);\n\n// 填充占位符\n// 操作Blob类型的变量\nFileInputStream fis = new FileInputStream(\"coffee.png\");\nps.setBlob(1, fis);\nps.setInt(2, 25);\n\nps.execute();\n\nfis.close();\nJDBCUtils.closeResource(conn, ps);\n```\n\n\n\n### 4.4 从数据表中读取大数据类型\n\n```java\nString sql = \"SELECT id, name, email, birth, photo FROM customer WHERE id = ?\";\nconn = getConnection();\nps = conn.prepareStatement(sql);\nps.setInt(1, 8);\nrs = ps.executeQuery();\nif(rs.next()){\n	Integer id = rs.getInt(1);\n    String name = rs.getString(2);\n	String email = rs.getString(3);\n    Date birth = rs.getDate(4);\n	Customer cust = new Customer(id, name, email, birth);\n    System.out.println(cust); \n    //读取Blob类型的字段\n	Blob photo = rs.getBlob(5);\n	InputStream is = photo.getBinaryStream();\n	OutputStream os = new FileOutputStream(\"c.jpg\");\n	byte [] buffer = new byte[1024];\n	int len = 0;\n	while((len = is.read(buffer)) != -1){\n		os.write(buffer, 0, len);\n	}\n    JDBCUtils.closeResource(conn, ps, rs);\n		\n	if(is != null){\n		is.close();\n	}\n		\n	if(os !=  null){\n		os.close();\n	}\n    \n}\n\n```\n\n\n\n## 第5章 批量插入\n\n### 5.1 批量执行SQL语句\n\n当需要成批插入或者更新记录时，可以采用Java的批量**更新**机制，这一机制允许多条语句一次性提交给数据库批量处理。通常情况下比单独提交处理更有效率\n\nJDBC的批量处理语句包括下面三个方法：\n\n- **addBatch(String)：添加需要批量处理的SQL语句或是参数；**\n- **executeBatch()：执行批量处理语句；**\n- **clearBatch():清空缓存的数据**\n\n通常我们会遇到两种批量执行SQL语句的情况：\n\n- 多条SQL语句的批量处理；\n- 一个SQL语句的批量传参；\n\n\n\n### 5.2 高效的批量插入\n\n举例：向数据表中插入20000条数据\n\n- 数据库中提供一个goods表。创建如下：\n\n```sql\nCREATE TABLE goods(\nid INT PRIMARY KEY AUTO_INCREMENT,\nNAME VARCHAR(20)\n);\n```\n\n\n\n#### 5.2.1 实现层次一：使用Statement\n\n```java\nConnection conn = JDBCUtils.getConnection();\nStatement st = conn.createStatement();\nfor(int i = 1;i <= 20000;i++){\n	String sql = \"insert into goods(name) values(\'name_\' + \"+ i +\")\";\n	st.executeUpdate(sql);\n}\n```\n\n\n\n#### 5.2.2 实现层次二：使用PreparedStatement\n\n```java\nlong start = System.currentTimeMillis();\n		\nConnection conn = JDBCUtils.getConnection();\n		\nString sql = \"insert into goods(name)values(?)\";\nPreparedStatement ps = conn.prepareStatement(sql);\nfor(int i = 1;i <= 20000;i++){\n	ps.setString(1, \"name_\" + i);\n	ps.executeUpdate();\n}\n		\nlong end = System.currentTimeMillis();\nSystem.out.println(\"花费的时间为：\" + (end - start));//82340\n		\n		\nJDBCUtils.closeResource(conn, ps);\n```\n\n#### 5.2.3 实现层次三\n\n```java\n/*\n * 修改1： 使用 addBatch() / executeBatch() / clearBatch()\n * 修改2：mysql服务器默认是关闭批处理的，我们需要通过一个参数，让mysql开启批处理的支持。\n * 		 ?rewriteBatchedStatements=true 写在配置文件的url后面\n * 修改3：使用更新的mysql 驱动：mysql-connector-java-5.1.37-bin.jar\n * \n */\n@Test\npublic void testInsert1() throws Exception{\n	long start = System.currentTimeMillis();\n		\n	Connection conn = JDBCUtils.getConnection();\n		\n	String sql = \"insert into goods(name)values(?)\";\n	PreparedStatement ps = conn.prepareStatement(sql);\n		\n	for(int i = 1;i <= 1000000;i++){\n		ps.setString(1, \"name_\" + i);\n			\n		//1.“攒”sql\n		ps.addBatch();\n		if(i % 500 == 0){\n			//2.执行\n			ps.executeBatch();\n			//3.清空\n			ps.clearBatch();\n		}\n	}\n		\n	long end = System.currentTimeMillis();\n	System.out.println(\"花费的时间为：\" + (end - start));//20000条：625                                                                         //1000000条:14733  \n		\n	JDBCUtils.closeResource(conn, ps);\n}\n```\n\n#### 5.2.4 实现层次四\n\n```java\n/*\n* 层次四：在层次三的基础上操作\n* 使用Connection 的 setAutoCommit(false)  /  commit()\n*/\n@Test\npublic void testInsert2() throws Exception{\n	long start = System.currentTimeMillis();\n		\n	Connection conn = JDBCUtils.getConnection();\n		\n	//1.设置为不自动提交数据\n	conn.setAutoCommit(false);\n		\n	String sql = \"insert into goods(name)values(?)\";\n	PreparedStatement ps = conn.prepareStatement(sql);\n		\n	for(int i = 1;i <= 1000000;i++){\n		ps.setString(1, \"name_\" + i);\n			\n		//1.“攒”sql\n		ps.addBatch();\n			\n		if(i % 500 == 0){\n			//2.执行\n			ps.executeBatch();\n			//3.清空\n			ps.clearBatch();\n		}\n	}\n		\n	//2.提交数据\n	conn.commit();\n		\n	long end = System.currentTimeMillis();\n	System.out.println(\"花费的时间为：\" + (end - start));//1000000条:4978 \n		\n	JDBCUtils.closeResource(conn, ps);\n}\n```\n\n\n\n## 第6章： 数据库事务\n\n### 6.1 数据库事务介绍\n\n- **事务：一组逻辑操作单元,使数据从一种状态变换到另一种状态。**\n\n- **事务处理（事务操作）：**保证所有事务都作为一个工作单元来执行，即使出现了故障，都不能改变这种执行方式。当在一个事务中执行多个操作时，要么所有的事务都**被提交(commit)**，那么这些修改就永久地保存下来；要么数据库管理系统将放弃所作的所有修改，整个事务**回滚(rollback)**到最初状态。\n\n- 为确保数据库中数据的**一致性**，数据的操纵应当是离散的成组的逻辑单元：当它全部完成时，数据的一致性可以保持，而当这个单元中的一部分操作失败，整个事务应全部视为错误，所有从起始点以后的操作应全部回退到开始状态。 \n\n### 6.2 JDBC事务处理\n\n- 数据一旦提交，就不可回滚。\n\n- 数据什么时候意味着提交？\n\n  - **当一个连接对象被创建时，默认情况下是自动提交事务**：每次执行一个 SQL 语句时，如果执行成功，就会向数据库自动提交，而不能回滚。\n  - **关闭数据库连接，数据就会自动的提交。**如果多个操作，每个操作使用的是自己单独的连接，则无法保证事务。即同一个事务的多个操作必须在同一个连接下。\n\n- **JDBC程序中为了让多个 SQL 语句作为一个事务执行：**\n\n  - 调用 Connection 对象的 **setAutoCommit(false);** 以取消自动提交事务\n  - 在所有的 SQL 语句都成功执行后，调用 **commit();** 方法提交事务\n  - 在出现异常时，调用 **rollback();** 方法回滚事务\n\n  > 若此时 Connection 没有被关闭，还可能被重复使用，则需要恢复其自动提交状态 setAutoCommit(true)。尤其是在使用数据库连接池技术时，执行close()方法前，建议恢复自动提交状态。\n\n【案例：用户AA向用户BB转账100】\n\n```java\npublic void testJDBCTransaction() {\n	Connection conn = null;\n	try {\n		// 1.获取数据库连接\n		conn = JDBCUtils.getConnection();\n		// 2.开启事务\n		conn.setAutoCommit(false);\n		// 3.进行数据库操作\n		String sql1 = \"update user_table set balance = balance - 100 where user = ?\";\n		update(conn, sql1, \"AA\");\n\n		// 模拟网络异常\n		//System.out.println(10 / 0);\n\n		String sql2 = \"update user_table set balance = balance + 100 where user = ?\";\n		update(conn, sql2, \"BB\");\n		// 4.若没有异常，则提交事务\n		conn.commit();\n	} catch (Exception e) {\n		e.printStackTrace();\n		// 5.若有异常，则回滚事务\n		try {\n			conn.rollback();\n		} catch (SQLException e1) {\n			e1.printStackTrace();\n		}\n    } finally {\n        try {\n			//6.恢复每次DML操作的自动提交功能\n			conn.setAutoCommit(true);\n		} catch (SQLException e) {\n			e.printStackTrace();\n		}\n        //7.关闭连接\n		JDBCUtils.closeResource(conn, null, null); \n    }  \n}\n\n```\n\n其中，对数据库操作的方法为：\n\n```java\n//使用事务以后的通用的增删改操作（version 2.0）\npublic void update(Connection conn ,String sql, Object... args) {\n	PreparedStatement ps = null;\n	try {\n		// 1.获取PreparedStatement的实例 (或：预编译sql语句)\n		ps = conn.prepareStatement(sql);\n		// 2.填充占位符\n		for (int i = 0; i < args.length; i++) {\n			ps.setObject(i + 1, args[i]);\n		}\n		// 3.执行sql语句\n		ps.execute();\n	} catch (Exception e) {\n		e.printStackTrace();\n	} finally {\n		// 4.关闭资源\n		JDBCUtils.closeResource(null, ps);\n\n	}\n}\n```\n\n\n\n### 6.3 事务的ACID属性    \n\n1. **原子性（Atomicity）**\n   原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。 \n\n2. **一致性（Consistency）**\n   事务必须使数据库从一个一致性状态变换到另外一个一致性状态。\n\n3. **隔离性（Isolation）**\n   事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。\n\n4. **持久性（Durability）**\n   持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响。\n\n#### 6.3.1 数据库的并发问题\n\n- 对于同时运行的多个事务, 当这些事务访问数据库中相同的数据时, 如果没有采取必要的隔离机制, 就会导致各种并发问题:\n  - **脏读**: 对于两个事务 T1, T2, T1 读取了已经被 T2 更新但还**没有被提交**的字段。之后, 若 T2 回滚, T1读取的内容就是临时且无效的。\n  - **不可重复读**: 对于两个事务T1, T2, T1 读取了一个字段, 然后 T2 **更新**了该字段。之后, T1再次读取同一个字段, 值就不同了。\n  - **幻读**: 对于两个事务T1, T2, T1 从一个表中读取了一个字段, 然后 T2 在该表中**插入**了一些新的行。之后, 如果 T1 再次读取同一个表, 就会多出几行。\n\n- **数据库事务的隔离性**: 数据库系统必须具有隔离并发运行各个事务的能力, 使它们不会相互影响, 避免各种并发问题。\n\n- 一个事务与其他事务隔离的程度称为隔离级别。数据库规定了多种事务隔离级别, 不同隔离级别对应不同的干扰程度, **隔离级别越高, 数据一致性就越好, 但并发性越弱。**\n\n#### 6.3.2 四种隔离级别\n\n- 数据库提供的4种事务隔离级别：\n\n  ![1555586275271](尚硅谷_宋红康_JDBC.assets/1555586275271.png)\n\n- Oracle 支持的 2 种事务隔离级别：**READ COMMITED**, SERIALIZABLE。 Oracle 默认的事务隔离级别为: **READ COMMITED** 。\n\n\n- Mysql 支持 4 种事务隔离级别。Mysql 默认的事务隔离级别为: **REPEATABLE READ。**\n\n\n#### 6.3.3 在MySql中设置隔离级别\n\n- 每启动一个 mysql 程序, 就会获得一个单独的数据库连接. 每个数据库连接都有一个全局变量 @@tx_isolation, 表示当前的事务隔离级别。\n\n- 查看当前的隔离级别: \n\n  ```mysql\n  SELECT @@tx_isolation;\n  ```\n\n- 设置当前 mySQL 连接的隔离级别:  \n\n  ```mysql\n  set  transaction isolation level read committed;\n  ```\n\n- 设置数据库系统的全局的隔离级别:\n\n  ```mysql\n  set global transaction isolation level read committed;\n  ```\n\n- 补充操作：\n\n  - 创建mysql数据库用户：\n\n    ```mysql\n    create user tom identified by \'abc123\';\n    ```\n\n  - 授予权限\n\n    ```mysql\n    #授予通过网络方式登录的tom用户，对所有库所有表的全部权限，密码设为abc123.\n    grant all privileges on *.* to tom@\'%\'  identified by \'abc123\'; \n    \n     #给tom用户使用本地命令行方式，授予atguigudb这个库下的所有表的插删改查的权限。\n    grant select,insert,delete,update on atguigudb.* to tom@localhost identified by \'abc123\'; \n    \n    ```\n\n    \n\n## 第7章：DAO及相关实现类\n\n- DAO：Data Access Object访问数据信息的类和接口，包括了对数据的CRUD（Create、Retrival、Update、Delete），而不包含任何业务相关的信息。有时也称作：BaseDAO\n- 作用：为了实现功能的模块化，更有利于代码的维护和升级。\n- 下面是尚硅谷JavaWeb阶段书城项目中DAO使用的体现：\n\n![1566726681515](尚硅谷_宋红康_JDBC.assets/1566726681515.png)\n\n- 层次结构：\n\n![1566745811244](尚硅谷_宋红康_JDBC.assets/1566745811244.png)\n\n### 【BaseDAO.java】\n\n```java\npackage com.atguigu.bookstore.dao;\n\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\n\nimport org.apache.commons.dbutils.QueryRunner;\nimport org.apache.commons.dbutils.handlers.BeanHandler;\nimport org.apache.commons.dbutils.handlers.BeanListHandler;\nimport org.apache.commons.dbutils.handlers.ScalarHandler;\n\n\n/**\n * 定义一个用来被继承的对数据库进行基本操作的Dao\n * \n * @author HanYanBing\n *\n * @param <T>\n */\npublic abstract class BaseDao<T> {\n	private QueryRunner queryRunner = new QueryRunner();\n	// 定义一个变量来接收泛型的类型\n	private Class<T> type;\n\n	// 获取T的Class对象，获取泛型的类型，泛型是在被子类继承时才确定\n	public BaseDao() {\n		// 获取子类的类型\n		Class clazz = this.getClass();\n		// 获取父类的类型\n		// getGenericSuperclass()用来获取当前类的父类的类型\n		// ParameterizedType表示的是带泛型的类型\n		ParameterizedType parameterizedType = (ParameterizedType) clazz.getGenericSuperclass();\n		// 获取具体的泛型类型 getActualTypeArguments获取具体的泛型的类型\n		// 这个方法会返回一个Type的数组\n		Type[] types = parameterizedType.getActualTypeArguments();\n		// 获取具体的泛型的类型·\n		this.type = (Class<T>) types[0];\n	}\n\n	/**\n	 * 通用的增删改操作\n	 * \n	 * @param sql\n	 * @param params\n	 * @return\n	 */\n	public int update(Connection conn,String sql, Object... params) {\n		int count = 0;\n		try {\n			count = queryRunner.update(conn, sql, params);\n		} catch (SQLException e) {\n			e.printStackTrace();\n		} \n		return count;\n	}\n\n	/**\n	 * 获取一个对象\n	 * \n	 * @param sql\n	 * @param params\n	 * @return\n	 */\n	public T getBean(Connection conn,String sql, Object... params) {\n		T t = null;\n		try {\n			t = queryRunner.query(conn, sql, new BeanHandler<T>(type), params);\n		} catch (SQLException e) {\n			e.printStackTrace();\n		} \n		return t;\n	}\n\n	/**\n	 * 获取所有对象\n	 * \n	 * @param sql\n	 * @param params\n	 * @return\n	 */\n	public List<T> getBeanList(Connection conn,String sql, Object... params) {\n		List<T> list = null;\n		try {\n			list = queryRunner.query(conn, sql, new BeanListHandler<T>(type), params);\n		} catch (SQLException e) {\n			e.printStackTrace();\n		} \n		return list;\n	}\n\n	/**\n	 * 获取一个但一值得方法，专门用来执行像 select count(*)...这样的sql语句\n	 * \n	 * @param sql\n	 * @param params\n	 * @return\n	 */\n	public Object getValue(Connection conn,String sql, Object... params) {\n		Object count = null;\n		try {\n			// 调用queryRunner的query方法获取一个单一的值\n			count = queryRunner.query(conn, sql, new ScalarHandler<>(), params);\n		} catch (SQLException e) {\n			e.printStackTrace();\n		} \n		return count;\n	}\n}\n```\n\n### 【BookDAO.java】\n\n```java\npackage com.atguigu.bookstore.dao;\n\nimport java.sql.Connection;\nimport java.util.List;\n\nimport com.atguigu.bookstore.beans.Book;\nimport com.atguigu.bookstore.beans.Page;\n\npublic interface BookDao {\n\n	/**\n	 * 从数据库中查询出所有的记录\n	 * \n	 * @return\n	 */\n	List<Book> getBooks(Connection conn);\n\n	/**\n	 * 向数据库中插入一条记录\n	 * \n	 * @param book\n	 */\n	void saveBook(Connection conn,Book book);\n\n	/**\n	 * 从数据库中根据图书的id删除一条记录\n	 * \n	 * @param bookId\n	 */\n	void deleteBookById(Connection conn,String bookId);\n\n	/**\n	 * 根据图书的id从数据库中查询出一条记录\n	 * \n	 * @param bookId\n	 * @return\n	 */\n	Book getBookById(Connection conn,String bookId);\n\n	/**\n	 * 根据图书的id从数据库中更新一条记录\n	 * \n	 * @param book\n	 */\n	void updateBook(Connection conn,Book book);\n\n	/**\n	 * 获取带分页的图书信息\n	 * \n	 * @param page：是只包含了用户输入的pageNo属性的page对象\n	 * @return 返回的Page对象是包含了所有属性的Page对象\n	 */\n	Page<Book> getPageBooks(Connection conn,Page<Book> page);\n\n	/**\n	 * 获取带分页和价格范围的图书信息\n	 * \n	 * @param page：是只包含了用户输入的pageNo属性的page对象\n	 * @return 返回的Page对象是包含了所有属性的Page对象\n	 */\n	Page<Book> getPageBooksByPrice(Connection conn,Page<Book> page, double minPrice, double maxPrice);\n\n}\n```\n\n### 【UserDAO.java】\n\n```java\npackage com.atguigu.bookstore.dao;\n\nimport java.sql.Connection;\n\nimport com.atguigu.bookstore.beans.User;\n\npublic interface UserDao {\n\n	/**\n	 * 根据User对象中的用户名和密码从数据库中获取一条记录\n	 * \n	 * @param user\n	 * @return User 数据库中有记录 null 数据库中无此记录\n	 */\n	User getUser(Connection conn,User user);\n\n	/**\n	 * 根据User对象中的用户名从数据库中获取一条记录\n	 * \n	 * @param user\n	 * @return true 数据库中有记录 false 数据库中无此记录\n	 */\n	boolean checkUsername(Connection conn,User user);\n\n	/**\n	 * 向数据库中插入User对象\n	 * \n	 * @param user\n	 */\n	void saveUser(Connection conn,User user);\n}\n```\n\n### 【BookDaoImpl.java】\n\n```java\npackage com.atguigu.bookstore.dao.impl;\n\nimport java.sql.Connection;\nimport java.util.List;\n\nimport com.atguigu.bookstore.beans.Book;\nimport com.atguigu.bookstore.beans.Page;\nimport com.atguigu.bookstore.dao.BaseDao;\nimport com.atguigu.bookstore.dao.BookDao;\n\npublic class BookDaoImpl extends BaseDao<Book> implements BookDao {\n\n	@Override\n	public List<Book> getBooks(Connection conn) {\n		// 调用BaseDao中得到一个List的方法\n		List<Book> beanList = null;\n		// 写sql语句\n		String sql = \"select id,title,author,price,sales,stock,img_path imgPath from books\";\n		beanList = getBeanList(conn,sql);\n		return beanList;\n	}\n\n	@Override\n	public void saveBook(Connection conn,Book book) {\n		// 写sql语句\n		String sql = \"insert into books(title,author,price,sales,stock,img_path) values(?,?,?,?,?,?)\";\n		// 调用BaseDao中通用的增删改的方法\n		update(conn,sql, book.getTitle(), book.getAuthor(), book.getPrice(), book.getSales(), book.getStock(),book.getImgPath());\n	}\n\n	@Override\n	public void deleteBookById(Connection conn,String bookId) {\n		// 写sql语句\n		String sql = \"DELETE FROM books WHERE id = ?\";\n		// 调用BaseDao中通用增删改的方法\n		update(conn,sql, bookId);\n			\n	}\n\n	@Override\n	public Book getBookById(Connection conn,String bookId) {\n		// 调用BaseDao中获取一个对象的方法\n		Book book = null;\n		// 写sql语句\n		String sql = \"select id,title,author,price,sales,stock,img_path imgPath from books where id = ?\";\n		book = getBean(conn,sql, bookId);\n		return book;\n	}\n\n	@Override\n	public void updateBook(Connection conn,Book book) {\n		// 写sql语句\n		String sql = \"update books set title = ? , author = ? , price = ? , sales = ? , stock = ? where id = ?\";\n		// 调用BaseDao中通用的增删改的方法\n		update(conn,sql, book.getTitle(), book.getAuthor(), book.getPrice(), book.getSales(), book.getStock(), book.getId());\n	}\n\n	@Override\n	public Page<Book> getPageBooks(Connection conn,Page<Book> page) {\n		// 获取数据库中图书的总记录数\n		String sql = \"select count(*) from books\";\n		// 调用BaseDao中获取一个单一值的方法\n		long totalRecord = (long) getValue(conn,sql);\n		// 将总记录数设置都page对象中\n		page.setTotalRecord((int) totalRecord);\n\n		// 获取当前页中的记录存放的List\n		String sql2 = \"select id,title,author,price,sales,stock,img_path imgPath from books limit ?,?\";\n		// 调用BaseDao中获取一个集合的方法\n		List<Book> beanList = getBeanList(conn,sql2, (page.getPageNo() - 1) * Page.PAGE_SIZE, Page.PAGE_SIZE);\n		// 将这个List设置到page对象中\n		page.setList(beanList);\n		return page;\n	}\n\n	@Override\n	public Page<Book> getPageBooksByPrice(Connection conn,Page<Book> page, double minPrice, double maxPrice) {\n		// 获取数据库中图书的总记录数\n		String sql = \"select count(*) from books where price between ? and ?\";\n		// 调用BaseDao中获取一个单一值的方法\n		long totalRecord = (long) getValue(conn,sql,minPrice,maxPrice);\n		// 将总记录数设置都page对象中\n		page.setTotalRecord((int) totalRecord);\n\n		// 获取当前页中的记录存放的List\n		String sql2 = \"select id,title,author,price,sales,stock,img_path imgPath from books where price between ? and ? limit ?,?\";\n		// 调用BaseDao中获取一个集合的方法\n		List<Book> beanList = getBeanList(conn,sql2, minPrice , maxPrice , (page.getPageNo() - 1) * Page.PAGE_SIZE, Page.PAGE_SIZE);\n		// 将这个List设置到page对象中\n		page.setList(beanList);\n		\n		return page;\n	}\n\n}\n```\n\n### 【UserDaoImpl.java】\n\n```java\npackage com.atguigu.bookstore.dao.impl;\n\nimport java.sql.Connection;\n\nimport com.atguigu.bookstore.beans.User;\nimport com.atguigu.bookstore.dao.BaseDao;\nimport com.atguigu.bookstore.dao.UserDao;\n\npublic class UserDaoImpl extends BaseDao<User> implements UserDao {\n\n	@Override\n	public User getUser(Connection conn,User user) {\n		// 调用BaseDao中获取一个对象的方法\n		User bean = null;\n		// 写sql语句\n		String sql = \"select id,username,password,email from users where username = ? and password = ?\";\n		bean = getBean(conn,sql, user.getUsername(), user.getPassword());\n		return bean;\n	}\n\n	@Override\n	public boolean checkUsername(Connection conn,User user) {\n		// 调用BaseDao中获取一个对象的方法\n		User bean = null;\n		// 写sql语句\n		String sql = \"select id,username,password,email from users where username = ?\";\n		bean = getBean(conn,sql, user.getUsername());\n		return bean != null;\n	}\n\n	@Override\n	public void saveUser(Connection conn,User user) {\n		//写sql语句\n		String sql = \"insert into users(username,password,email) values(?,?,?)\";\n		//调用BaseDao中通用的增删改的方法\n		update(conn,sql, user.getUsername(),user.getPassword(),user.getEmail());\n	}\n\n}\n```\n\n### 【Book.java】\n\n```java\npackage com.atguigu.bookstore.beans;\n/**\n * 图书类\n * @author songhongkang\n *\n */\npublic class Book {\n\n	private Integer id;\n	private String title; // 书名\n	private String author; // 作者\n	private double price; // 价格\n	private Integer sales; // 销量\n	private Integer stock; // 库存\n	private String imgPath = \"static/img/default.jpg\"; // 封面图片的路径\n	//构造器，get()，set()，toString()方法略\n}\n```\n\n### 【Page.java】\n\n```java\npackage com.atguigu.bookstore.beans;\n\nimport java.util.List;\n/**\n * 页码类\n * @author songhongkang\n *\n */\npublic class Page<T> {\n\n	private List<T> list; // 每页查到的记录存放的集合\n	public static final int PAGE_SIZE = 4; // 每页显示的记录数\n	private int pageNo; // 当前页\n//	private int totalPageNo; // 总页数，通过计算得到\n	private int totalRecord; // 总记录数，通过查询数据库得到\n\n```\n\n### 【User.java】\n\n```java\npackage com.atguigu.bookstore.beans;\n/**\n * 用户类\n * @author songhongkang\n *\n */\npublic class User {\n\n	private Integer id;\n	private String username;\n	private String password;\n	private String email;\n\n```\n\n\n\n## 第8章：数据库连接池\n\n### 8.1 JDBC数据库连接池的必要性\n\n- 在使用开发基于数据库的web程序时，传统的模式基本是按以下步骤：　　\n  - **在主程序（如servlet、beans）中建立数据库连接**\n  - **进行sql操作**\n  - **断开数据库连接**\n\n- 这种模式开发，存在的问题:\n  - 普通的JDBC数据库连接使用 DriverManager 来获取，每次向数据库建立连接的时候都要将 Connection 加载到内存中，再验证用户名和密码(得花费0.05s～1s的时间)。需要数据库连接的时候，就向数据库要求一个，执行完成后再断开连接。这样的方式将会消耗大量的资源和时间。**数据库的连接资源并没有得到很好的重复利用。**若同时有几百人甚至几千人在线，频繁的进行数据库连接操作将占用很多的系统资源，严重的甚至会造成服务器的崩溃。\n  - **对于每一次数据库连接，使用完后都得断开。**否则，如果程序出现异常而未能关闭，将会导致数据库系统中的内存泄漏，最终将导致重启数据库。（回忆：何为Java的内存泄漏？）\n  - **这种开发不能控制被创建的连接对象数**，系统资源会被毫无顾及的分配出去，如连接过多，也可能导致内存泄漏，服务器崩溃。 \n\n### 8.2 数据库连接池技术\n\n- 为解决传统开发中的数据库连接问题，可以采用数据库连接池技术。\n- **数据库连接池的基本思想**：就是为数据库连接建立一个“缓冲池”。预先在缓冲池中放入一定数量的连接，当需要建立数据库连接时，只需从“缓冲池”中取出一个，使用完毕之后再放回去。\n\n- **数据库连接池**负责分配、管理和释放数据库连接，它**允许应用程序重复使用一个现有的数据库连接，而不是重新建立一个**。\n- 数据库连接池在初始化时将创建一定数量的数据库连接放到连接池中，这些数据库连接的数量是由**最小数据库连接数来设定**的。无论这些数据库连接是否被使用，连接池都将一直保证至少拥有这么多的连接数量。连接池的**最大数据库连接数量**限定了这个连接池能占有的最大连接数，当应用程序向连接池请求的连接数超过最大连接数量时，这些请求将被加入到等待队列中。\n\n![1555593464033](尚硅谷_宋红康_JDBC.assets/1555593464033.png)\n\n- **工作原理：**\n\n![1555593598606](尚硅谷_宋红康_JDBC.assets/1555593598606.png)\n\n- **数据库连接池技术的优点**\n\n  **1. 资源重用**\n\n  由于数据库连接得以重用，避免了频繁创建，释放连接引起的大量性能开销。在减少系统消耗的基础上，另一方面也增加了系统运行环境的平稳性。\n\n  **2. 更快的系统反应速度**\n\n  数据库连接池在初始化过程中，往往已经创建了若干数据库连接置于连接池中备用。此时连接的初始化工作均已完成。对于业务请求处理而言，直接利用现有可用连接，避免了数据库连接初始化和释放过程的时间开销，从而减少了系统的响应时间\n\n  **3. 新的资源分配手段**\n\n  对于多应用共享同一数据库的系统而言，可在应用层通过数据库连接池的配置，实现某一应用最大可用数据库连接数的限制，避免某一应用独占所有的数据库资源\n\n  **4. 统一的连接管理，避免数据库连接泄漏**\n\n  在较为完善的数据库连接池实现中，可根据预先的占用超时设定，强制回收被占用连接，从而避免了常规数据库连接操作中可能出现的资源泄露\n\n\n### 8.3 多种开源的数据库连接池\n\n- JDBC 的数据库连接池使用 javax.sql.DataSource 来表示，DataSource 只是一个接口，该接口通常由服务器(Weblogic, WebSphere, Tomcat)提供实现，也有一些开源组织提供实现：\n  - **DBCP** 是Apache提供的数据库连接池。tomcat 服务器自带dbcp数据库连接池。**速度相对c3p0较快**，但因自身存在BUG，Hibernate3已不再提供支持。\n  - **C3P0** 是一个开源组织提供的一个数据库连接池，**速度相对较慢，稳定性还可以。**hibernate官方推荐使用\n  - **Proxool** 是sourceforge下的一个开源项目数据库连接池，有监控连接池状态的功能，**稳定性较c3p0差一点**\n  - **BoneCP** 是一个开源组织提供的数据库连接池，速度快\n  - **Druid** 是阿里提供的数据库连接池，据说是集DBCP 、C3P0 、Proxool 优点于一身的数据库连接池，但是速度不确定是否有BoneCP快\n- DataSource 通常被称为数据源，它包含连接池和连接池管理两个部分，习惯上也经常把 DataSource 称为连接池\n- **DataSource用来取代DriverManager来获取Connection，获取速度快，同时可以大幅度提高数据库访问速度。**\n- 特别注意：\n  - 数据源和数据库连接不同，数据源无需创建多个，它是产生数据库连接的工厂，因此**整个应用只需要一个数据源即可。**\n  - 当数据库访问结束后，程序还是像以前一样关闭数据库连接：conn.close(); 但conn.close()并没有关闭数据库的物理连接，它仅仅把数据库连接释放，归还给了数据库连接池。\n\n#### 8.3.1 C3P0数据库连接池\n\n- 获取连接方式一\n\n```java\n//使用C3P0数据库连接池的方式，获取数据库的连接：不推荐\npublic static Connection getConnection1() throws Exception{\n	ComboPooledDataSource cpds = new ComboPooledDataSource();\n	cpds.setDriverClass(\"com.mysql.jdbc.Driver\"); \n	cpds.setJdbcUrl(\"jdbc:mysql://localhost:3306/test\");\n	cpds.setUser(\"root\");\n	cpds.setPassword(\"abc123\");\n		\n//	cpds.setMaxPoolSize(100);\n	\n	Connection conn = cpds.getConnection();\n	return conn;\n}\n```\n\n\n\n- 获取连接方式二\n\n```java\n//使用C3P0数据库连接池的配置文件方式，获取数据库的连接：推荐\nprivate static DataSource cpds = new ComboPooledDataSource(\"helloc3p0\");\npublic static Connection getConnection2() throws SQLException{\n	Connection conn = cpds.getConnection();\n	return conn;\n}\n```\n\n其中，src下的配置文件为：【c3p0-config.xml】\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<c3p0-config>\n	<named-config name=\"helloc3p0\">\n		<!-- 获取连接的4个基本信息 -->\n		<property name=\"user\">root</property>\n		<property name=\"password\">abc123</property>\n		<property name=\"jdbcUrl\">jdbc:mysql:///test</property>\n		<property name=\"driverClass\">com.mysql.jdbc.Driver</property>\n		\n		<!-- 涉及到数据库连接池的管理的相关属性的设置 -->\n		<!-- 若数据库中连接数不足时, 一次向数据库服务器申请多少个连接 -->\n		<property name=\"acquireIncrement\">5</property>\n		<!-- 初始化数据库连接池时连接的数量 -->\n		<property name=\"initialPoolSize\">5</property>\n		<!-- 数据库连接池中的最小的数据库连接数 -->\n		<property name=\"minPoolSize\">5</property>\n		<!-- 数据库连接池中的最大的数据库连接数 -->\n		<property name=\"maxPoolSize\">10</property>\n		<!-- C3P0 数据库连接池可以维护的 Statement 的个数 -->\n		<property name=\"maxStatements\">20</property>\n		<!-- 每个连接同时可以使用的 Statement 对象的个数 -->\n		<property name=\"maxStatementsPerConnection\">5</property>\n\n	</named-config>\n</c3p0-config>\n```\n\n\n\n#### 8.3.2 DBCP数据库连接池\n\n- DBCP 是 Apache 软件基金组织下的开源连接池实现，该连接池依赖该组织下的另一个开源系统：Common-pool。如需使用该连接池实现，应在系统中增加如下两个 jar 文件：\n  - Commons-dbcp.jar：连接池的实现\n  - Commons-pool.jar：连接池实现的依赖库\n- **Tomcat 的连接池正是采用该连接池来实现的。**该数据库连接池既可以与应用服务器整合使用，也可由应用程序独立使用。\n- 数据源和数据库连接不同，数据源无需创建多个，它是产生数据库连接的工厂，因此整个应用只需要一个数据源即可。\n- 当数据库访问结束后，程序还是像以前一样关闭数据库连接：conn.close(); 但上面的代码并没有关闭数据库的物理连接，它仅仅把数据库连接释放，归还给了数据库连接池。\n- 配置属性说明\n\n| 属性                       | 默认值 | 说明                                                         |\n| -------------------------- | ------ | ------------------------------------------------------------ |\n| initialSize                | 0      | 连接池启动时创建的初始化连接数量                             |\n| maxActive                  | 8      | 连接池中可同时连接的最大的连接数                             |\n| maxIdle                    | 8      | 连接池中最大的空闲的连接数，超过的空闲连接将被释放，如果设置为负数表示不限制 |\n| minIdle                    | 0      | 连接池中最小的空闲的连接数，低于这个数量会被创建新的连接。该参数越接近maxIdle，性能越好，因为连接的创建和销毁，都是需要消耗资源的；但是不能太大。 |\n| maxWait                    | 无限制 | 最大等待时间，当没有可用连接时，连接池等待连接释放的最大时间，超过该时间限制会抛出异常，如果设置-1表示无限等待 |\n| poolPreparedStatements     | false  | 开启池的Statement是否prepared                                |\n| maxOpenPreparedStatements  | 无限制 | 开启池的prepared 后的同时最大连接数                          |\n| minEvictableIdleTimeMillis |        | 连接池中连接，在时间段内一直空闲， 被逐出连接池的时间        |\n| removeAbandonedTimeout     | 300    | 超过时间限制，回收没有用(废弃)的连接                         |\n| removeAbandoned            | false  | 超过removeAbandonedTimeout时间后，是否进 行没用连接（废弃）的回收 |\n\n\n\n- 获取连接方式一：\n\n```java\npublic static Connection getConnection3() throws Exception {\n	BasicDataSource source = new BasicDataSource();\n		\n	source.setDriverClassName(\"com.mysql.jdbc.Driver\");\n	source.setUrl(\"jdbc:mysql:///test\");\n	source.setUsername(\"root\");\n	source.setPassword(\"abc123\");\n		\n	//\n	source.setInitialSize(10);\n		\n	Connection conn = source.getConnection();\n	return conn;\n}\n```\n\n- 获取连接方式二：\n\n```java\n//使用dbcp数据库连接池的配置文件方式，获取数据库的连接：推荐\nprivate static DataSource source = null;\nstatic{\n	try {\n		Properties pros = new Properties();\n		\n		InputStream is = DBCPTest.class.getClassLoader().getResourceAsStream(\"dbcp.properties\");\n			\n		pros.load(is);\n		//根据提供的BasicDataSourceFactory创建对应的DataSource对象\n		source = BasicDataSourceFactory.createDataSource(pros);\n	} catch (Exception e) {\n		e.printStackTrace();\n	}\n		\n}\npublic static Connection getConnection4() throws Exception {\n		\n	Connection conn = source.getConnection();\n	\n	return conn;\n}\n```\n\n其中，src下的配置文件为：【dbcp.properties】\n\n```properties\ndriverClassName=com.mysql.jdbc.Driver\nurl=jdbc:mysql://localhost:3306/test?rewriteBatchedStatements=true&useServerPrepStmts=false\nusername=root\npassword=abc123\n\ninitialSize=10\n#...\n```\n\n\n\n#### 8.3.3 Druid（德鲁伊）数据库连接池\n\nDruid是阿里巴巴开源平台上一个数据库连接池实现，它结合了C3P0、DBCP、Proxool等DB池的优点，同时加入了日志监控，可以很好的监控DB池连接和SQL的执行情况，可以说是针对监控而生的DB连接池，**可以说是目前最好的连接池之一。**\n\n```java\npackage com.atguigu.druid;\n\nimport java.sql.Connection;\nimport java.util.Properties;\n\nimport javax.sql.DataSource;\n\nimport com.alibaba.druid.pool.DruidDataSourceFactory;\n\npublic class TestDruid {\n	public static void main(String[] args) throws Exception {\n		Properties pro = new Properties();		 pro.load(TestDruid.class.getClassLoader().getResourceAsStream(\"druid.properties\"));\n		DataSource ds = DruidDataSourceFactory.createDataSource(pro);\n		Connection conn = ds.getConnection();\n		System.out.println(conn);\n	}\n}\n\n```\n\n其中，src下的配置文件为：【druid.properties】\n\n```java\nurl=jdbc:mysql://localhost:3306/test?rewriteBatchedStatements=true\nusername=root\npassword=123456\ndriverClassName=com.mysql.jdbc.Driver\n\ninitialSize=10\nmaxActive=20\nmaxWait=1000\nfilters=wall\n```\n\n- 详细配置参数：\n\n| **配置**                      | **缺省** | **说明**                                                     |\n| ----------------------------- | -------- | ------------------------------------------------------------ |\n| name                          |          | 配置这个属性的意义在于，如果存在多个数据源，监控的时候可以通过名字来区分开来。   如果没有配置，将会生成一个名字，格式是：”DataSource-” +   System.identityHashCode(this) |\n| url                           |          | 连接数据库的url，不同数据库不一样。例如：mysql :   jdbc:mysql://10.20.153.104:3306/druid2      oracle :   jdbc:oracle:thin:@10.20.149.85:1521:ocnauto |\n| username                      |          | 连接数据库的用户名                                           |\n| password                      |          | 连接数据库的密码。如果你不希望密码直接写在配置文件中，可以使用ConfigFilter。详细看这里：<https://github.com/alibaba/druid/wiki/%E4%BD%BF%E7%94%A8ConfigFilter> |\n| driverClassName               |          | 根据url自动识别   这一项可配可不配，如果不配置druid会根据url自动识别dbType，然后选择相应的driverClassName(建议配置下) |\n| initialSize                   | 0        | 初始化时建立物理连接的个数。初始化发生在显示调用init方法，或者第一次getConnection时 |\n| maxActive                     | 8        | 最大连接池数量                                               |\n| maxIdle                       | 8        | 已经不再使用，配置了也没效果                                 |\n| minIdle                       |          | 最小连接池数量                                               |\n| maxWait                       |          | 获取连接时最大等待时间，单位毫秒。配置了maxWait之后，缺省启用公平锁，并发效率会有所下降，如果需要可以通过配置useUnfairLock属性为true使用非公平锁。 |\n| poolPreparedStatements        | false    | 是否缓存preparedStatement，也就是PSCache。PSCache对支持游标的数据库性能提升巨大，比如说oracle。在mysql下建议关闭。 |\n| maxOpenPreparedStatements     | -1       | 要启用PSCache，必须配置大于0，当大于0时，poolPreparedStatements自动触发修改为true。在Druid中，不会存在Oracle下PSCache占用内存过多的问题，可以把这个数值配置大一些，比如说100 |\n| validationQuery               |          | 用来检测连接是否有效的sql，要求是一个查询语句。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会其作用。 |\n| testOnBorrow                  | true     | 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。 |\n| testOnReturn                  | false    | 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能 |\n| testWhileIdle                 | false    | 建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。 |\n| timeBetweenEvictionRunsMillis |          | 有两个含义： 1)Destroy线程会检测连接的间隔时间2)testWhileIdle的判断依据，详细看testWhileIdle属性的说明 |\n| numTestsPerEvictionRun        |          | 不再使用，一个DruidDataSource只支持一个EvictionRun           |\n| minEvictableIdleTimeMillis    |          |                                                              |\n| connectionInitSqls            |          | 物理连接初始化的时候执行的sql                                |\n| exceptionSorter               |          | 根据dbType自动识别   当数据库抛出一些不可恢复的异常时，抛弃连接 |\n| filters                       |          | 属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有：   监控统计用的filter:stat日志用的filter:log4j防御sql注入的filter:wall |\n| proxyFilters                  |          | 类型是List，如果同时配置了filters和proxyFilters，是组合关系，并非替换关系 |\n\n\n\n## 第9章：Apache-DBUtils实现CRUD操作\n\n### 9.1 Apache-DBUtils简介\n\n- commons-dbutils 是 Apache 组织提供的一个开源 JDBC工具类库，它是对JDBC的简单封装，学习成本极低，并且使用dbutils能极大简化jdbc编码的工作量，同时也不会影响程序的性能。\n\n- API介绍：\n  - org.apache.commons.dbutils.QueryRunner\n  - org.apache.commons.dbutils.ResultSetHandler\n  - 工具类：org.apache.commons.dbutils.DbUtils   \n- API包说明：\n\n![1555595163263](尚硅谷_宋红康_JDBC.assets/1555595163263.png)\n\n![1555595198644](尚硅谷_宋红康_JDBC.assets/1555595198644.png)\n\n\n\n\n\n### 9.2 主要API的使用\n\n#### 9.2.1 DbUtils\n\n- DbUtils ：提供如关闭连接、装载JDBC驱动程序等常规工作的工具类，里面的所有方法都是静态的。主要方法如下：\n  - **public static void close(…) throws java.sql.SQLException**：　DbUtils类提供了三个重载的关闭方法。这些方法检查所提供的参数是不是NULL，如果不是的话，它们就关闭Connection、Statement和ResultSet。\n  - public static void closeQuietly(…): 这一类方法不仅能在Connection、Statement和ResultSet为NULL情况下避免关闭，还能隐藏一些在程序中抛出的SQLEeception。\n  - public static void commitAndClose(Connection conn)throws SQLException： 用来提交连接的事务，然后关闭连接\n  - public static void commitAndCloseQuietly(Connection conn)： 用来提交连接，然后关闭连接，并且在关闭连接时不抛出SQL异常。 \n  - public static void rollback(Connection conn)throws SQLException：允许conn为null，因为方法内部做了判断\n  - public static void rollbackAndClose(Connection conn)throws SQLException\n  - rollbackAndCloseQuietly(Connection)\n  - public static boolean loadDriver(java.lang.String driverClassName)：这一方装载并注册JDBC驱动程序，如果成功就返回true。使用该方法，你不需要捕捉这个异常ClassNotFoundException。\n\n#### 9.2.2 QueryRunner类\n\n- **该类简单化了SQL查询，它与ResultSetHandler组合在一起使用可以完成大部分的数据库操作，能够大大减少编码量。**\n\n- QueryRunner类提供了两个构造器：\n  - 默认的构造器\n  - 需要一个 javax.sql.DataSource 来作参数的构造器\n\n- QueryRunner类的主要方法：\n  - **更新**\n    - public int update(Connection conn, String sql, Object... params) throws SQLException:用来执行一个更新（插入、更新或删除）操作。\n    - ......\n  - **插入**\n    - public <T> T insert(Connection conn,String sql,ResultSetHandler<T> rsh, Object... params) throws SQLException：只支持INSERT语句，其中 rsh - The handler used to create the result object from the ResultSet of auto-generated keys.  返回值: An object generated by the handler.即自动生成的键值\n    - ....\n  - **批处理**\n    - public int[] batch(Connection conn,String sql,Object[][] params)throws SQLException： INSERT, UPDATE, or DELETE语句\n    - public <T> T insertBatch(Connection conn,String sql,ResultSetHandler<T> rsh,Object[][] params)throws SQLException：只支持INSERT语句\n    - .....\n  - **查询**\n    - public Object query(Connection conn, String sql, ResultSetHandler rsh,Object... params) throws SQLException：执行一个查询操作，在这个查询中，对象数组中的每个元素值被用来作为查询语句的置换参数。该方法会自行处理 PreparedStatement 和 ResultSet 的创建和关闭。\n    - ...... \n\n- 测试\n\n```java\n// 测试添加\n@Test\npublic void testInsert() throws Exception {\n	QueryRunner runner = new QueryRunner();\n	Connection conn = JDBCUtils.getConnection3();\n	String sql = \"insert into customers(name,email,birth)values(?,?,?)\";\n	int count = runner.update(conn, sql, \"何成飞\", \"he@qq.com\", \"1992-09-08\");\n\n	System.out.println(\"添加了\" + count + \"条记录\");\n		\n	JDBCUtils.closeResource(conn, null);\n\n}\n```\n\n```java\n// 测试删除\n@Test\npublic void testDelete() throws Exception {\n	QueryRunner runner = new QueryRunner();\n	Connection conn = JDBCUtils.getConnection3();\n	String sql = \"delete from customers where id < ?\";\n	int count = runner.update(conn, sql,3);\n\n	System.out.println(\"删除了\" + count + \"条记录\");\n		\n	JDBCUtils.closeResource(conn, null);\n\n}\n```\n\n\n\n#### 9.2.3 ResultSetHandler接口及实现类\n\n- 该接口用于处理 java.sql.ResultSet，将数据按要求转换为另一种形式。\n\n- ResultSetHandler 接口提供了一个单独的方法：Object handle (java.sql.ResultSet .rs)。\n\n- 接口的主要实现类：\n\n  - ArrayHandler：把结果集中的第一行数据转成对象数组。\n\n  - ArrayListHandler：把结果集中的每一行数据都转成一个数组，再存放到List中。\n\n  - **BeanHandler：**将结果集中的第一行数据封装到一个对应的JavaBean实例中。\n\n  - **BeanListHandler：**将结果集中的每一行数据都封装到一个对应的JavaBean实例中，存放到List里。\n\n  - ColumnListHandler：将结果集中某一列的数据存放到List中。\n\n  - KeyedHandler(name)：将结果集中的每一行数据都封装到一个Map里，再把这些map再存到一个map里，其key为指定的key。\n\n  - **MapHandler：**将结果集中的第一行数据封装到一个Map里，key是列名，value就是对应的值。\n\n  - **MapListHandler：**将结果集中的每一行数据都封装到一个Map里，然后再存放到List\n\n  - **ScalarHandler：**查询单个值对象\n\n    \n\n- 测试\n\n```java\n/*\n * 测试查询:查询一条记录\n * \n * 使用ResultSetHandler的实现类：BeanHandler\n */\n@Test\npublic void testQueryInstance() throws Exception{\n	QueryRunner runner = new QueryRunner();\n\n	Connection conn = JDBCUtils.getConnection3();\n		\n	String sql = \"select id,name,email,birth from customers where id = ?\";\n		\n	//\n	BeanHandler<Customer> handler = new BeanHandler<>(Customer.class);\n	Customer customer = runner.query(conn, sql, handler, 23);\n	System.out.println(customer);	\n	JDBCUtils.closeResource(conn, null);\n}\n```\n\n```java\n/*\n * 测试查询:查询多条记录构成的集合\n * \n * 使用ResultSetHandler的实现类：BeanListHandler\n */\n@Test\npublic void testQueryList() throws Exception{\n	QueryRunner runner = new QueryRunner();\n\n	Connection conn = JDBCUtils.getConnection3();\n		\n	String sql = \"select id,name,email,birth from customers where id < ?\";\n		\n	//\n	BeanListHandler<Customer> handler = new BeanListHandler<>(Customer.class);\n	List<Customer> list = runner.query(conn, sql, handler, 23);\n	list.forEach(System.out::println);\n		\n	JDBCUtils.closeResource(conn, null);\n}\n```\n\n```java\n/*\n * 自定义ResultSetHandler的实现类\n */\n@Test\npublic void testQueryInstance1() throws Exception{\n	QueryRunner runner = new QueryRunner();\n\n	Connection conn = JDBCUtils.getConnection3();\n		\n	String sql = \"select id,name,email,birth from customers where id = ?\";\n		\n	ResultSetHandler<Customer> handler = new ResultSetHandler<Customer>() {\n\n		@Override\n		public Customer handle(ResultSet rs) throws SQLException {\n			System.out.println(\"handle\");\n//			return new Customer(1,\"Tom\",\"tom@126.com\",new Date(123323432L));\n				\n			if(rs.next()){\n				int id = rs.getInt(\"id\");\n				String name = rs.getString(\"name\");\n				String email = rs.getString(\"email\");\n				Date birth = rs.getDate(\"birth\");\n					\n				return new Customer(id, name, email, birth);\n			}\n			return null;\n				\n		}\n	};\n		\n	Customer customer = runner.query(conn, sql, handler, 23);\n		\n	System.out.println(customer);\n		\n	JDBCUtils.closeResource(conn, null);\n}\n```\n\n```java\n/*\n * 如何查询类似于最大的，最小的，平均的，总和，个数相关的数据，\n * 使用ScalarHandler\n * \n */\n@Test\npublic void testQueryValue() throws Exception{\n	QueryRunner runner = new QueryRunner();\n\n	Connection conn = JDBCUtils.getConnection3();\n		\n	//测试一：\n//	String sql = \"select count(*) from customers where id < ?\";\n//	ScalarHandler handler = new ScalarHandler();\n//	long count = (long) runner.query(conn, sql, handler, 20);\n//	System.out.println(count);\n		\n	//测试二：\n	String sql = \"select max(birth) from customers\";\n	ScalarHandler handler = new ScalarHandler();\n	Date birth = (Date) runner.query(conn, sql, handler);\n	System.out.println(birth);\n		\n	JDBCUtils.closeResource(conn, null);\n}\n```\n\n## JDBC总结\n\n```java\n总结\n@Test\npublic void testUpdateWithTx() {\n		\n	Connection conn = null;\n	try {\n		//1.获取连接的操作（\n		//① 手写的连接：JDBCUtils.getConnection();\n		//② 使用数据库连接池：C3P0;DBCP;Druid\n		//2.对数据表进行一系列CRUD操作\n		//① 使用PreparedStatement实现通用的增删改、查询操作（version 1.0 \\ version 2.0)\n//version2.0的增删改public void update(Connection conn,String sql,Object ... args){}\n//version2.0的查询 public <T> T getInstance(Connection conn,Class<T> clazz,String sql,Object ... args){}\n		//② 使用dbutils提供的jar包中提供的QueryRunner类\n			\n		//提交数据\n		conn.commit();\n			\n	\n	} catch (Exception e) {\n		e.printStackTrace();\n			\n			\n		try {\n			//回滚数据\n			conn.rollback();\n		} catch (SQLException e1) {\n			e1.printStackTrace();\n		}\n			\n	}finally{\n		//3.关闭连接等操作\n		//① JDBCUtils.closeResource();\n		//② 使用dbutils提供的jar包中提供的DbUtils类提供了关闭的相关操作\n			\n	}\n}\n```\n\n','2023-05-14 05:06:35',0),(23,2,'Springboot','Springboot核心技术','## 01、基础入门-SpringBoot2课程介绍\n\n1. Spring Boot 2核心技术\n\n2. Spring Boot 2响应式编程\n\n- 学习要求\n  -熟悉Spring基础\n  -熟悉Maven使用\n- 环境要求\n  - Java8及以上\n  - Maven 3.3及以上\n- 学习资料\n  - [Spring Boot官网](https://spring.io/projects/spring-boot)\n  - [Spring Boot官方文档](https://docs.spring.io/spring-boot/docs/)\n  - [本课程文档地址](https://www.yuque.com/atguigu/springboot)\n  - [视频地址1](http://www.gulixueyuan.com/)、[视频地址2](https://www.bilibili.com/video/BV19K4y1L7MT?p=1)\n  - [源码地址](https://gitee.com/leifengyang/springboot2)\n\n## 02、基础入门-Spring生态圈\n\n[Spring官网](https://spring.io/)\n\n### Spring能做什么\n\n#### Spring的能力\n\n![20210205004146543.png](1)\n\n#### Spring的生态\n\n覆盖了：\n\n- web开发\n- 数据访问\n- 安全控制\n- 分布式\n- 消息服务\n- 移动开发\n- 批处理\n- ......\n\n#### Spring5重大升级\n\n- 响应式编程\n\n![在这里插入图片描述](image/20210205004250581.png)\n\n- 内部源码设计\n\n基于Java8的一些新特性，如：接口默认实现。重新设计源码架构。\n\n\n### 为什么用SpringBoot\n\n> Spring Boot makes it easy to create stand-alone, production-grade Spring based Applications that you can \"just run\".[link](https://spring.io/projects/spring-boot)\n>\n> 能快速创建出生产级别的Spring应用。\n\n#### SpringBoot优点\n\n- Create stand-alone Spring applications\n  - 创建独立Spring应用\n- Embed Tomcat, Jetty or Undertow directly (no need to deploy WAR files)\n  - 内嵌web服务器\n- Provide opinionated \'starter\' dependencies to simplify your build configuration\n  - 自动starter依赖，简化构建配置\n- Automatically configure Spring and 3rd party libraries whenever possible\n  - 自动配置Spring以及第三方功能\n- Provide production-ready features such as metrics, health checks, and externalized configuration\n  - 提供生产级别的监控、健康检查及外部化配置\n- Absolutely no code generation and no requirement for XML configuration\n  - 无代码生成、无需编写XML\n\n\n- SpringBoot是整合Spring技术栈的一站式框架\n- SpringBoot是简化Spring技术栈的快速开发脚手架\n\n\n#### SpringBoot缺点\n\n- 人称版本帝，迭代快，需要时刻关注变化\n- 封装太深，内部原理复杂，不容易精通\n\n## 03、基础入门-SpringBoot的大时代背景\n\n### 微服务\n\n> In short, the **microservice architectural style** is an approach to developing a single application as a **suite of small services**, each **running in its own process** and communicating with **lightweight** mechanisms, often an **HTTP** resource API. These services are built around **business capabilities** and **independently deployable** by fully **automated deployment** machinery. There is a bare minimum of centralized management of these services, which may be **written in different programming languages** and use different data storage technologies.——[James Lewis and Martin Fowler (2014)](https://martinfowler.com/articles/microservices.html)\n\n- 微服务是一种架构风格\n- 一个应用拆分为一组小型服务\n- 每个服务运行在自己的进程内，也就是可独立部署和升级\n- 服务之间使用轻量级HTTP交互\n- 服务围绕业务功能拆分\n- 可以由全自动部署机制独立部署\n- 去中心化，服务自治。服务可以使用不同的语言、不同的存储技术\n\n### 分布式\n\n![在这里插入图片描述](image/2021020500434620.png)\n\n#### 分布式的困难\n\n- 远程调用\n- 服务发现\n- 负载均衡\n- 服务容错\n- 配置管理\n- 服务监控\n- 链路追踪\n- 日志管理\n- 任务调度\n- ......\n\n#### 分布式的解决\n\n- SpringBoot + SpringCloud\n\n![20210205004523307.png](4)\n\n### 云原生\n\n原生应用如何上云。 Cloud Native\n\n#### 上云的困难\n\n- 服务自愈\n- 弹性伸缩\n- 服务隔离\n- 自动化部署\n- 灰度发布\n- 流量治理\n- ......\n\n#### 上云的解决\n\n![20210205004621290.png](2)\n\n## 04、基础入门-SpringBoot官方文档架构\n\n- [Spring Boot官网](https://spring.io/projects/spring-boot)\n- [Spring Boot官方文档](https://docs.spring.io/spring-boot/docs/)\n\n### 官网文档架构\n\n![在这里插入图片描述](image/20210205004733270.png)\n![在这里插入图片描述](image/20210205004828702.png)\n\n[查看版本新特性](https://github.com/spring-projects/spring-boot/wiki#release-notes)\n\n![在这里插入图片描述](image/20210205005342147.png)\n\n\n## 05、基础入门-SpringBoot-HelloWorld\n\n### 系统要求\n\n- Java 8\n- Maven 3.3+\n- IntelliJ IDEA 2019.1.2\n\n#### Maven配置文件\n\n新添内容：\n\n```xml\n<mirrors>\n	<mirror>\n		<id>nexus-aliyun</id>\n		<mirrorOf>central</mirrorOf>\n		<name>Nexus aliyun</name>\n		<url>http://maven.aliyun.com/nexus/content/groups/public</url>\n	</mirror>\n</mirrors>\n\n<profiles>\n	<profile>\n		<id>jdk-1.8</id>\n\n		<activation>\n			<activeByDefault>true</activeByDefault>\n			<jdk>1.8</jdk>\n		</activation>\n\n		<properties>\n			<maven.compiler.source>1.8</maven.compiler.source>\n			<maven.compiler.target>1.8</maven.compiler.target>\n			<maven.compiler.compilerVersion>1.8</maven.compiler.compilerVersion>\n		</properties>\n	</profile>\n</profiles>\n```\n\n### HelloWorld项目\n\n需求：浏览发送/hello请求，响应 “Hello，Spring Boot 2”\n\n#### 创建maven工程\n\n\n#### 引入依赖\n\n```xml\n<parent>\n	<groupId>org.springframework.boot</groupId>\n	<artifactId>spring-boot-starter-parent</artifactId>\n	<version>2.3.4.RELEASE</version>\n</parent>\n\n<dependencies>\n	<dependency>\n		<groupId>org.springframework.boot</groupId>\n		<artifactId>spring-boot-starter-web</artifactId>\n	</dependency>\n</dependencies>\n```\n\n#### 创建主程序\n\n```java\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class MainApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(MainApplication.class, args);\n    }\n}\n\n```\n\n#### 编写业务\n\n```java\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\npublic class HelloController {\n    @RequestMapping(\"/hello\")\n    public String handle01(){\n        return \"Hello, Spring Boot 2!\";\n    }\n}\n```\n\n#### 运行&测试\n\n- 运行`MainApplication`类\n- 浏览器输入`http://localhost:8888/hello`，将会输出`Hello, Spring Boot 2!`。\n\n#### 设置配置\n\nmaven工程的resource文件夹中创建application.properties文件。\n\n```properties\n# 设置端口号\nserver.port=8888\n```\n\n[更多配置信息](https://docs.spring.io/spring-boot/docs/2.3.7.RELEASE/reference/html/appendix-application-properties.html#common-application-properties-server)\n\n#### 打包部署\n\n在pom.xml添加\n\n```xml\n<build>\n	<plugins>\n		<plugin>\n			<groupId>org.springframework.boot</groupId>\n			<artifactId>spring-boot-maven-plugin</artifactId>\n		</plugin>\n	</plugins>\n</build>\n```\n\n在IDEA的Maven插件上点击运行 clean 、package，把helloworld工程项目的打包成jar包，\n\n打包好的jar包被生成在helloworld工程项目的target文件夹内。\n\n用cmd运行`java -jar boot-01-helloworld-1.0-SNAPSHOT.jar`，既可以运行helloworld工程项目。\n\n将jar包直接在目标服务器执行即可。\n\n## 06、基础入门-SpringBoot-依赖管理特性\n\n- 父项目做依赖管理\n\n```xml\n依赖管理\n<parent>\n	<groupId>org.springframework.boot</groupId>\n	<artifactId>spring-boot-starter-parent</artifactId>\n	<version>2.3.4.RELEASE</version>\n</parent>\n\n上面项目的父项目如下：\n<parent>\n	<groupId>org.springframework.boot</groupId>\n	<artifactId>spring-boot-dependencies</artifactId>\n	<version>2.3.4.RELEASE</version>\n</parent>\n\n它几乎声明了所有开发中常用的依赖的版本号，自动版本仲裁机制\n```\n\n- 开发导入starter场景启动器\n  1. 见到很多 spring-boot-starter-* ： *就某种场景\n  2. 只要引入starter，这个场景的所有常规需要的依赖我们都自动引入\n  3. [更多SpringBoot所有支持的场景](https://docs.spring.io/spring-boot/docs/current/reference/html/using-spring-boot.html#using-boot-starter)\n  4. 见到的  *-spring-boot-starter： 第三方为我们提供的简化开发的场景启动器。\n\n```xml\n所有场景启动器最底层的依赖\n<dependency>\n	<groupId>org.springframework.boot</groupId>\n	<artifactId>spring-boot-starter</artifactId>\n	<version>2.3.4.RELEASE</version>\n	<scope>compile</scope>\n</dependency>\n```\n\n- 无需关注版本号，自动版本仲裁\n  1. 引入依赖默认都可以不写版本\n  2. 引入非版本仲裁的jar，要写版本号。\n\n- 可以修改默认版本号\n  1. 查看spring-boot-dependencies里面规定当前依赖的版本 用的 key。\n  2. 在当前项目里面重写配置，如下面的代码。\n\n```xml\n<properties>\n	<mysql.version>5.1.43</mysql.version>\n</properties>\n```\n\n---\n\nIDEA快捷键：\n\n- ` ctrl + shift + alt + U`：以图的方式显示项目中依赖之间的关系。\n- `alt + ins`：相当于Eclipse的 Ctrl + N，创建新类，新包等。\n\n## 07、基础入门-SpringBoot-自动配置特性\n\n\n- 自动配好Tomcat\n  - 引入Tomcat依赖。\n  - 配置Tomcat\n\n```xml\n<dependency>\n	<groupId>org.springframework.boot</groupId>\n	<artifactId>spring-boot-starter-tomcat</artifactId>\n	<version>2.3.4.RELEASE</version>\n	<scope>compile</scope>\n</dependency>\n```\n\n- 自动配好SpringMVC\n  - 引入SpringMVC全套组件\n  - 自动配好SpringMVC常用组件（功能）\n\n- 自动配好Web常见功能，如：字符编码问题\n  - SpringBoot帮我们配置好了所有web开发的常见场景\n\n```java\npublic static void main(String[] args) {\n    //1、返回我们IOC容器\n    ConfigurableApplicationContext run = SpringApplication.run(MainApplication.class, args);\n\n    //2、查看容器里面的组件\n    String[] names = run.getBeanDefinitionNames();\n    for (String name : names) {\n        System.out.println(name);\n    }\n}\n```\n\n- 默认的包结构\n  - 主程序所在包及其下面的所有子包里面的组件都会被默认扫描进来\n  - 无需以前的包扫描配置\n  - 想要改变扫描路径\n    - @SpringBootApplication(scanBasePackages=\"com.lun\")\n    - @ComponentScan 指定扫描路径\n\n```java\n@SpringBootApplication\n等同于\n@SpringBootConfiguration\n@EnableAutoConfiguration\n@ComponentScan(\"com.lun\")\n```\n\n- 各种配置拥有默认值\n  - 默认配置最终都是映射到某个类上，如：`MultipartProperties`\n  - 配置文件的值最终会绑定每个类上，这个类会在容器中创建对象\n\n- 按需加载所有自动配置项\n  - 非常多的starter\n  - 引入了哪些场景这个场景的自动配置才会开启\n  - SpringBoot所有的自动配置功能都在 spring-boot-autoconfigure 包里面\n  - \n- ......\n\n\n## 08、底层注解-@Configuration详解\n\n- 基本使用\n  - Full模式与Lite模式\n  - 示例\n\n```java\n/**\n * 1、配置类里面使用@Bean标注在方法上给容器注册组件，默认也是单实例的\n * 2、配置类本身也是组件\n * 3、proxyBeanMethods：代理bean的方法\n *      Full(proxyBeanMethods = true)（保证每个@Bean方法被调用多少次返回的组件都是单实例的）（默认）\n *      Lite(proxyBeanMethods = false)（每个@Bean方法被调用多少次返回的组件都是新创建的）\n */\n@Configuration(proxyBeanMethods = false) //告诉SpringBoot这是一个配置类 == 配置文件\npublic class MyConfig {\n\n    /**\n     * Full:外部无论对配置类中的这个组件注册方法调用多少次获取的都是之前注册容器中的单实例对象\n     * @return\n     */\n    @Bean //给容器中添加组件。以方法名作为组件的id。返回类型就是组件类型。返回的值，就是组件在容器中的实例\n    public User user01(){\n        User zhangsan = new User(\"zhangsan\", 18);\n        //user组件依赖了Pet组件\n        zhangsan.setPet(tomcatPet());\n        return zhangsan;\n    }\n\n    @Bean(\"tom\")\n    public Pet tomcatPet(){\n        return new Pet(\"tomcat\");\n    }\n}\n```\n\n\n@Configuration测试代码如下:\n\n```java\n@SpringBootConfiguration\n@EnableAutoConfiguration\n@ComponentScan(\"com.atguigu.boot\")\npublic class MainApplication {\n\n    public static void main(String[] args) {\n    //1、返回我们IOC容器\n        ConfigurableApplicationContext run = SpringApplication.run(MainApplication.class, args);\n\n    //2、查看容器里面的组件\n        String[] names = run.getBeanDefinitionNames();\n        for (String name : names) {\n            System.out.println(name);\n        }\n\n    //3、从容器中获取组件\n        Pet tom01 = run.getBean(\"tom\", Pet.class);\n        Pet tom02 = run.getBean(\"tom\", Pet.class);\n        System.out.println(\"组件：\"+(tom01 == tom02));\n\n    //4、com.atguigu.boot.config.MyConfig$$EnhancerBySpringCGLIB$$51f1e1ca@1654a892\n        MyConfig bean = run.getBean(MyConfig.class);\n        System.out.println(bean);\n\n    //如果@Configuration(proxyBeanMethods = true)代理对象调用方法。SpringBoot总会检查这个组件是否在容器中有。\n        //保持组件单实例\n        User user = bean.user01();\n        User user1 = bean.user01();\n        System.out.println(user == user1);\n\n        User user01 = run.getBean(\"user01\", User.class);\n        Pet tom = run.getBean(\"tom\", Pet.class);\n\n        System.out.println(\"用户的宠物：\"+(user01.getPet() == tom));\n    }\n}\n```\n\n- 最佳实战\n  - 配置 类组件之间**无依赖关系**用Lite模式加速容器启动过程，减少判断\n  - 配置 类组件之间**有依赖关系**，方法会被调用得到之前单实例组件，用Full模式（默认）\n\n> lite 英 [laɪt]   美 [laɪt]  \n> adj. 低热量的，清淡的(light的一种拼写方法);类似…的劣质品\n\n---\n\nIDEA快捷键：\n\n- `Alt + Ins`:生成getter，setter、构造器等代码。\n- `Ctrl + Alt + B`:查看类的具体实现代码。\n\n## 09、底层注解-@Import导入组件\n\n@Bean、@Component、@Controller、@Service、@Repository，它们是Spring的基本标签，在Spring Boot中并未改变它们原来的功能。\n\n@ComponentScan 在[07、基础入门-SpringBoot-自动配置特性](#)有用例。\n\n\n@Import({User.class, DBHelper.class})给容器中**自动创建出这两个类型的组件**、默认组件的名字就是全类名\n\n```java\n@Import({User.class, DBHelper.class})\n@Configuration(proxyBeanMethods = false) //告诉SpringBoot这是一个配置类 == 配置文件\npublic class MyConfig {\n}\n```\n\n测试类：\n\n```java\n//1、返回我们IOC容器\nConfigurableApplicationContext run = SpringApplication.run(MainApplication.class, args);\n\n//...\n\n//5、获取组件\nString[] beanNamesForType = run.getBeanNamesForType(User.class);\n\nfor (String s : beanNamesForType) {\n    System.out.println(s);\n}\n\nDBHelper bean1 = run.getBean(DBHelper.class);\nSystem.out.println(bean1);\n```\n\n## 10、底层注解-@Conditional条件装配\n\n**条件装配：满足Conditional指定的条件，则进行组件注入**\n\n![在这里插入图片描述](image/20210205005453173.png)\n\n\n用@ConditionalOnMissingBean举例说明\n\n```java\n@Configuration(proxyBeanMethods = false)\n@ConditionalOnMissingBean(name = \"tom\")//没有tom名字的Bean时，MyConfig类的Bean才能生效。\npublic class MyConfig {\n\n    @Bean\n    public User user01(){\n        User zhangsan = new User(\"zhangsan\", 18);\n        zhangsan.setPet(tomcatPet());\n        return zhangsan;\n    }\n\n    @Bean(\"tom22\")\n    public Pet tomcatPet(){\n        return new Pet(\"tomcat\");\n    }\n}\n\npublic static void main(String[] args) {\n    //1、返回我们IOC容器\n    ConfigurableApplicationContext run = SpringApplication.run(MainApplication.class, args);\n\n    //2、查看容器里面的组件\n    String[] names = run.getBeanDefinitionNames();\n    for (String name : names) {\n        System.out.println(name);\n    }\n\n    boolean tom = run.containsBean(\"tom\");\n    System.out.println(\"容器中Tom组件：\"+tom);//false\n\n    boolean user01 = run.containsBean(\"user01\");\n    System.out.println(\"容器中user01组件：\"+user01);//true\n\n    boolean tom22 = run.containsBean(\"tom22\");\n    System.out.println(\"容器中tom22组件：\"+tom22);//true\n\n}\n```\n\n## 11、底层注解-@ImportResource导入Spring配置文件\n\n比如，公司使用bean.xml文件生成配置bean，然而你为了省事，想继续复用bean.xml，@ImportResource粉墨登场。\n\nbean.xml：\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans ...\">\n\n    <bean id=\"haha\" class=\"com.lun.boot.bean.User\">\n        <property name=\"name\" value=\"zhangsan\"></property>\n        <property name=\"age\" value=\"18\"></property>\n    </bean>\n\n    <bean id=\"hehe\" class=\"com.lun.boot.bean.Pet\">\n        <property name=\"name\" value=\"tomcat\"></property>\n    </bean>\n</beans>\n```\n\n使用方法：\n\n```java\n@ImportResource(\"classpath:beans.xml\")\npublic class MyConfig {\n...\n}\n```\n\n测试类：\n\n```java\npublic static void main(String[] args) {\n    //1、返回我们IOC容器\n    ConfigurableApplicationContext run = SpringApplication.run(MainApplication.class, args);\n\n	boolean haha = run.containsBean(\"haha\");\n	boolean hehe = run.containsBean(\"hehe\");\n	System.out.println(\"haha：\"+haha);//true\n	System.out.println(\"hehe：\"+hehe);//true\n}\n```\n\n## 12、底层注解-@ConfigurationProperties配置绑定\n\n如何使用Java读取到properties文件中的内容，并且把它封装到JavaBean中，以供随时使用\n\n传统方法：\n\n```java\npublic class getProperties {\n     public static void main(String[] args) throws FileNotFoundException, IOException {\n         Properties pps = new Properties();\n         pps.load(new FileInputStream(\"a.properties\"));\n         Enumeration enum1 = pps.propertyNames();//得到配置文件的名字\n         while(enum1.hasMoreElements()) {\n             String strKey = (String) enum1.nextElement();\n             String strValue = pps.getProperty(strKey);\n             System.out.println(strKey + \"=\" + strValue);\n             //封装到JavaBean。\n         }\n     }\n }\n```\n\n---\n\nSpring Boot一种配置配置绑定：\n\n@ConfigurationProperties + @Component\n\n假设有配置文件application.properties\n\n```properties\nmycar.brand=BYD\nmycar.price=100000\n```\n\n只有在容器中的组件，才会拥有SpringBoot提供的强大功能\n\n```java\n@Component\n@ConfigurationProperties(prefix = \"mycar\")\npublic class Car {\n...\n}\n```\n\n---\n\nSpring Boot另一种配置配置绑定：\n\n@EnableConfigurationProperties + @ConfigurationProperties\n\n1. 开启Car配置绑定功能\n2. 把这个Car这个组件自动注册到容器中\n\n\n```java\n@EnableConfigurationProperties(Car.class)\npublic class MyConfig {\n...\n}\n```\n\n```java\n@ConfigurationProperties(prefix = \"mycar\")\npublic class Car {\n...\n}\n```\n\n## 13、自动配置【源码分析】-自动包规则原理\n\nSpring Boot应用的启动类：\n\n```java\n@SpringBootApplication\npublic class MainApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(MainApplication.class, args);\n    }\n\n}\n```\n\n分析下`@SpringBootApplication`\n\n```java\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@SpringBootConfiguration\n@EnableAutoConfiguration\n@ComponentScan(\n    excludeFilters = {@Filter(\n    type = FilterType.CUSTOM,\n    classes = {TypeExcludeFilter.class}\n), @Filter(\n    type = FilterType.CUSTOM,\n    classes = {AutoConfigurationExcludeFilter.class}\n)}\n)\npublic @interface SpringBootApplication {\n    ...\n}\n```\n\n重点分析`@SpringBootConfiguration`，`@EnableAutoConfiguration`，`@ComponentScan`。\n\n### @SpringBootConfiguration\n\n```java\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Configuration\npublic @interface SpringBootConfiguration {\n    @AliasFor(\n        annotation = Configuration.class\n    )\n    boolean proxyBeanMethods() default true;\n}\n```\n\n`@Configuration`代表当前是一个配置类。\n\n\n### @ComponentScan\n\n指定扫描哪些Spring注解。\n\n@ComponentScan 在[07、基础入门-SpringBoot-自动配置特性](#)有用例。\n\n### @EnableAutoConfiguration\n\n```java\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@AutoConfigurationPackage\n@Import(AutoConfigurationImportSelector.class)\npublic @interface EnableAutoConfiguration {\n    String ENABLED_OVERRIDE_PROPERTY = \"spring.boot.enableautoconfiguration\";\n\n    Class<?>[] exclude() default {};\n\n    String[] excludeName() default {};\n}\n```\n\n重点分析`@AutoConfigurationPackage`，`@Import(AutoConfigurationImportSelector.class)`。\n\n#### @AutoConfigurationPackage\n\n标签名直译为：自动配置包，指定了默认的包规则。\n\n```java\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@Import(AutoConfigurationPackages.Registrar.class)//给容器中导入一个组件\npublic @interface AutoConfigurationPackage {\n    String[] basePackages() default {};\n\n    Class<?>[] basePackageClasses() default {};\n}\n```\n\n1. 利用Registrar给容器中导入一系列组件\n2. 将指定的一个包下的所有组件导入进MainApplication所在包下。\n\n## 14、自动配置【源码分析】-初始加载自动配置类\n\n#### @Import(AutoConfigurationImportSelector.class)\n\n1. 利用`getAutoConfigurationEntry(annotationMetadata);`给容器中批量导入一些组件\n2. 调用`List<String> configurations = getCandidateConfigurations(annotationMetadata, attributes)`获取到所有需要导入到容器中的配置类\n3. 利用工厂加载 `Map<String, List<String>> loadSpringFactories(@Nullable ClassLoader classLoader);`得到所有的组件\n4. 从`META-INF/spring.factories`位置来加载一个文件。\n   - 默认扫描我们当前系统里面所有`META-INF/spring.factories`位置的文件\n   - `spring-boot-autoconfigure-2.3.4.RELEASE.jar`包里面也有`META-INF/spring.factories`\n\n![在这里插入图片描述](image/20210205005536620.png)\n\n```properties\n# 文件里面写死了spring-boot一启动就要给容器中加载的所有配置类\n# spring-boot-autoconfigure-2.3.4.RELEASE.jar/META-INF/spring.factories\n# Auto Configure\norg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\\norg.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\\norg.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\\n...\n```\n\n虽然我们127个场景的所有自动配置启动的时候默认全部加载，但是`xxxxAutoConfiguration`按照条件装配规则（`@Conditional`），最终会按需配置。\n\n如`AopAutoConfiguration`类：\n\n```java\n@Configuration(\n    proxyBeanMethods = false\n)\n@ConditionalOnProperty(\n    prefix = \"spring.aop\",\n    name = \"auto\",\n    havingValue = \"true\",\n    matchIfMissing = true\n)\npublic class AopAutoConfiguration {\n    public AopAutoConfiguration() {\n    }\n	...\n}\n```\n\n## 15、自动配置【源码分析】-自动配置流程\n\n\n以`DispatcherServletAutoConfiguration`的内部类`DispatcherServletConfiguration`为例子:\n\n```java\n@Bean\n@ConditionalOnBean(MultipartResolver.class)  //容器中有这个类型组件\n@ConditionalOnMissingBean(name = DispatcherServlet.MULTIPART_RESOLVER_BEAN_NAME) //容器中没有这个名字 multipartResolver 的组件\npublic MultipartResolver multipartResolver(MultipartResolver resolver) {\n	//给@Bean标注的方法传入了对象参数，这个参数的值就会从容器中找。\n	//SpringMVC multipartResolver。防止有些用户配置的文件上传解析器不符合规范\n	// Detect if the user has created a MultipartResolver but named it incorrectly\n	return resolver;//给容器中加入了文件上传解析器；\n}\n```\n\nSpringBoot默认会在底层配好所有的组件，但是**如果用户自己配置了以用户的优先**。\n\n\n**总结**：\n\n- SpringBoot先加载所有的自动配置类  xxxxxAutoConfiguration\n- 每个自动配置类按照条件进行生效，默认都会绑定配置文件指定的值。（xxxxProperties里面读取，xxxProperties和配置文件进行了绑定）\n- 生效的配置类就会给容器中装配很多组件\n- 只要容器中有这些组件，相当于这些功能就有了\n- 定制化配置\n  - 用户直接自己@Bean替换底层的组件\n  - 用户去看这个组件是获取的配置文件什么值就去修改。\n\n**xxxxxAutoConfiguration ---> 组件 ---> xxxxProperties里面拿值  ----> application.properties**\n\n## 16、最佳实践-SpringBoot应用如何编写\n\n- 引入场景依赖\n  - [官方文档](https://docs.spring.io/spring-boot/docs/current/reference/html/using-spring-boot.html#using-boot-starter)\n- 查看自动配置了哪些（选做）\n  - 自己分析，引入场景对应的自动配置一般都生效了\n  - 配置文件中debug=true开启自动配置报告。\n    - Negative（不生效）\n    - Positive（生效）\n- 是否需要修改\n  - 参照文档修改配置项\n    - [官方文档](https://docs.spring.io/spring-boot/docs/current/reference/html/appendix-application-properties.html#common-application-properties)\n    - 自己分析。xxxxProperties绑定了配置文件的哪些。\n  - 自定义加入或者替换组件\n    - @Bean、@Component...\n  - 自定义器  XXXXXCustomizer；\n  - ......\n\n## 17、最佳实践-Lombok简化开发\n\nLombok用标签方式代替构造器、getter/setter、toString()等鸡肋代码。\n\nspring boot已经管理Lombok。引入依赖：\n\n```xml\n <dependency>\n     <groupId>org.projectlombok</groupId>\n     <artifactId>lombok</artifactId>\n</dependency>\n```\n\nIDEA中File->Settings->Plugins，搜索安装Lombok插件。\n\n```java\n@NoArgsConstructor\n//@AllArgsConstructor\n@Data\n@ToString\n@EqualsAndHashCode\npublic class User {\n\n    private String name;\n    private Integer age;\n\n    private Pet pet;\n\n    public User(String name,Integer age){\n        this.name = name;\n        this.age = age;\n    }\n}\n```\n\n---\n\n简化日志开发\n\n```java\n@Slf4j\n@RestController\npublic class HelloController {\n    @RequestMapping(\"/hello\")\n    public String handle01(@RequestParam(\"name\") String name){\n        log.info(\"请求进来了....\");\n        return \"Hello, Spring Boot 2!\"+\"你好：\"+name;\n    }\n}\n```\n\n## 18、最佳实践-dev-tools\n\n> Spring Boot includes an additional set of tools that can make the application development experience a little more pleasant. The `spring-boot-devtools` module can be included in any project to provide additional development-time features.——[link](https://docs.spring.io/spring-boot/docs/2.3.8.RELEASE/reference/html/using-spring-boot.html#using-boot-devtools)\n>\n> Applications that use `spring-boot-devtools` automatically restart whenever files on the classpath change. This can be a useful feature when working in an IDE, as it gives a very fast feedback loop for code changes. By default, any entry on the classpath that points to a directory is monitored for changes. Note that certain resources, such as static assets and view templates, [do not need to restart the application](https://docs.spring.io/spring-boot/docs/2.3.8.RELEASE/reference/html/using-spring-boot.html#using-boot-devtools-restart-exclude).——[link](https://docs.spring.io/spring-boot/docs/2.3.8.RELEASE/reference/html/using-spring-boot.html#using-boot-devtools-restart)\n>\n> Triggering a restart\n>\n> As DevTools monitors classpath resources, the only way to trigger a restart is to update the classpath. The way in which you cause the classpath to be updated depends on the IDE that you are using:\n>\n> - In Eclipse, saving a modified file causes the classpath to be updated and triggers a restart.\n> - In IntelliJ IDEA, building the project (`Build -> Build Project`)(shortcut: Ctrl+F9) has the same effect.\n\n添加依赖：\n\n```xml\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-devtools</artifactId>\n        <optional>true</optional>\n    </dependency>\n</dependencies>\n```\n\n在IDEA中，项目或者页面修改以后：Ctrl+F9。\n\n## 19、最佳实践-Spring Initailizr\n\n[Spring Initailizr](https://start.spring.io/)是创建Spring Boot工程向导。\n\n在IDEA中，菜单栏New -> Project -> Spring Initailizr。\n\n## 20、配置文件-yaml的用法\n\n同以前的properties用法\n\nYAML 是 \"YAML Ain\'t Markup Language\"（YAML 不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是：\"Yet Another Markup Language\"（仍是一种标记语言）。 \n\n**非常适合用来做以数据为中心的配置文件**。\n\n### 基本语法\n\n- key: value；kv之间有空格\n- 大小写敏感\n- 使用缩进表示层级关系\n- 缩进不允许使用tab，只允许空格\n- 缩进的空格数不重要，只要相同层级的元素左对齐即可\n- \'#\'表示注释\n- 字符串无需加引号，如果要加，单引号\'\'、双引号\"\"表示字符串内容会被 转义、不转义\n\n### 数据类型\n\n- 字面量：单个的、不可再分的值。date、boolean、string、number、null\n\n```yaml\nk: v\n```\n\n- 对象：键值对的集合。map、hash、set、object \n\n```yaml\n#行内写法：  \n\nk: {k1:v1,k2:v2,k3:v3}\n\n#或\n\nk: \n  k1: v1\n  k2: v2\n  k3: v3\n```\n\n- 数组：一组按次序排列的值。array、list、queue\n\n```yaml\n#行内写法：  \n\nk: [v1,v2,v3]\n\n#或者\n\nk:\n - v1\n - v2\n - v3\n```\n\n### 实例\n\n```java\n@Data\npublic class Person {\n    private String userName;\n    private Boolean boss;\n    private Date birth;\n    private Integer age;\n    private Pet pet;\n    private String[] interests;\n    private List<String> animal;\n    private Map<String, Object> score;\n    private Set<Double> salarys;\n    private Map<String, List<Pet>> allPets;\n}\n\n@Data\npublic class Pet {\n    private String name;\n    private Double weight;\n}\n```\n\n用yaml表示以上对象\n\n```yaml\nperson:\n  userName: zhangsan\n  boss: false\n  birth: 2019/12/12 20:12:33\n  age: 18\n  pet: \n    name: tomcat\n    weight: 23.4\n  interests: [篮球,游泳]\n  animal: \n    - jerry\n    - mario\n  score:\n    english: \n      first: 30\n      second: 40\n      third: 50\n    math: [131,140,148]\n    chinese: {first: 128,second: 136}\n  salarys: [3999,4999.98,5999.99]\n  allPets:\n    sick:\n      - {name: tom}\n      - {name: jerry,weight: 47}\n    health: [{name: mario,weight: 47}]\n```\n\n## 21、配置文件-自定义类绑定的配置提示\n\n> You can easily generate your own configuration metadata file from items annotated with `@ConfigurationProperties` by using the `spring-boot-configuration-processor` jar. The jar includes a Java annotation processor which is invoked as your project is compiled.——[link](https://docs.spring.io/spring-boot/docs/2.4.2/reference/htmlsingle/#configuration-metadata-annotation-processor)\n\n自定义的类和配置文件绑定一般没有提示。若要提示，添加如下依赖：\n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-configuration-processor</artifactId>\n    <optional>true</optional>\n</dependency>\n\n<!-- 下面插件作用是工程打包时，不将spring-boot-configuration-processor打进包内，让其只在编码的时候有用 -->\n<build>\n    <plugins>\n        <plugin>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-maven-plugin</artifactId>\n            <configuration>\n                <excludes>\n                    <exclude>\n                        <groupId>org.springframework.boot</groupId>\n                        <artifactId>spring-boot-configuration-processor</artifactId>\n                    </exclude>\n                </excludes>\n            </configuration>\n        </plugin>\n    </plugins>\n</build>\n```\n\n## 22、web场景-web开发简介\n\nSpring Boot provides auto-configuration for Spring MVC that **works well with most applications.(大多场景我们都无需自定义配置)**\n\nThe auto-configuration adds the following features on top of Spring’s defaults:\n\n- Inclusion of `ContentNegotiatingViewResolver` and `BeanNameViewResolver` beans.\n\n  - 内容协商视图解析器和BeanName视图解析器\n\n- Support for serving static resources, including support for WebJars (covered [later in this document](https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-spring-mvc-static-content))).\n\n  - 静态资源（包括webjars）\n\n- Automatic registration of `Converter`, `GenericConverter`, and `Formatter` beans.\n\n  - 自动注册 `Converter，GenericConverter，Formatter `\n\n- Support for `HttpMessageConverters` (covered [later in this document](https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-spring-mvc-message-converters)).\n\n  - 支持 `HttpMessageConverters` （后来我们配合内容协商理解原理）\n\n- Automatic registration of `MessageCodesResolver` (covered [later in this document](https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-spring-message-codes)).\n\n  - 自动注册 `MessageCodesResolver` （国际化用）\n\n- Static `index.html` support.\n\n  - 静态index.html 页支持\n\n- Custom `Favicon` support (covered [later in this document](https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-spring-mvc-favicon)).\n\n  - 自定义 `Favicon`  \n\n- Automatic use of a `ConfigurableWebBindingInitializer` bean (covered [later in this document](https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-spring-mvc-web-binding-initializer)).\n\n  - 自动使用 `ConfigurableWebBindingInitializer` ，（DataBinder负责将请求数据绑定到JavaBean上）\n\n> If you want to keep those Spring Boot MVC customizations and make more [MVC customizations](https://docs.spring.io/spring/docs/5.2.9.RELEASE/spring-framework-reference/web.html#mvc) (interceptors, formatters, view controllers, and other features), you can add your own `@Configuration` class of type `WebMvcConfigurer` but **without** `@EnableWebMvc`.\n>\n> **不用@EnableWebMvc注解。使用** **`@Configuration`** **+** **`WebMvcConfigurer`** **自定义规则**\n\n> If you want to provide custom instances of `RequestMappingHandlerMapping`, `RequestMappingHandlerAdapter`, or `ExceptionHandlerExceptionResolver`, and still keep the Spring Boot MVC customizations, you can declare a bean of type `WebMvcRegistrations` and use it to provide custom instances of those components.\n>\n> **声明** **`WebMvcRegistrations`** **改变默认底层组件**\n\n> If you want to take complete control of Spring MVC, you can add your own `@Configuration` annotated with `@EnableWebMvc`, or alternatively add your own `@Configuration`-annotated `DelegatingWebMvcConfiguration` as described in the Javadoc of `@EnableWebMvc`.\n>\n> **使用** **`@EnableWebMvc+@Configuration+DelegatingWebMvcConfiguration 全面接管SpringMVC`**\n\n## 23、web场景-静态资源规则与定制化\n\n### 静态资源目录\n\n只要静态资源放在类路径下： called `/static` (or `/public` or `/resources` or `/META-INF/resources`\n\n访问 ： 当前项目根路径/ + 静态资源名 \n\n原理： 静态映射/**。\n\n请求进来，先去找Controller看能不能处理。不能处理的所有请求又都交给静态资源处理器。静态资源也找不到则响应404页面。\n\n也可以改变默认的静态资源路径，`/static`，`/public`,`/resources`, `/META-INF/resources`失效\n\n```yaml\nresources:\n  static-locations: [classpath:/haha/]\n```\n\n### 静态资源访问前缀\n\n```yaml\nspring:\n  mvc:\n    static-path-pattern: /res/**\n```\n\n当前项目 + static-path-pattern + 静态资源名 = 静态资源文件夹下找\n\n### webjar\n\n可用jar方式添加css，js等资源文件，\n\n[https://www.webjars.org/](https://www.webjars.org/)\n\n例如，添加jquery\n\n```xml\n<dependency>\n    <groupId>org.webjars</groupId>\n    <artifactId>jquery</artifactId>\n    <version>3.5.1</version>\n</dependency>\n```\n\n访问地址：[http://localhost:8080/webjars/**jquery/3.5.1/jquery.js**](http://localhost:8080/webjars/jquery/3.5.1/jquery.js)  后面地址要按照依赖里面的包路径。\n\n## 24、web场景-welcome与favicon功能\n\n[官方文档](https://docs.spring.io/spring-boot/docs/2.3.8.RELEASE/reference/htmlsingle/#boot-features-spring-mvc-welcome-page)\n\n### 欢迎页支持\n\n- 静态资源路径下  index.html。\n\n  - 可以配置静态资源路径\n  - 但是不可以配置静态资源的访问前缀。否则导致 index.html不能被默认访问\n\n```yaml\nspring:\n#  mvc:\n#    static-path-pattern: /res/**   这个会导致welcome page功能失效\n  resources:\n    static-locations: [classpath:/haha/]\n```\n\n- controller能处理/index。\n\n### 自定义Favicon\n\n指网页标签上的小图标。\n\nfavicon.ico 放在静态资源目录下即可。\n\n```yaml\nspring:\n#  mvc:\n#    static-path-pattern: /res/**   这个会导致 Favicon 功能失效\n```\n\n## 25、web场景-【源码分析】-静态资源原理\n\n- SpringBoot启动默认加载  xxxAutoConfiguration 类（自动配置类）\n- SpringMVC功能的自动配置类`WebMvcAutoConfiguration`，生效\n\n```java\n@Configuration(proxyBeanMethods = false)\n@ConditionalOnWebApplication(type = Type.SERVLET)\n@ConditionalOnClass({ Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class })\n@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)\n@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)\n@AutoConfigureAfter({ DispatcherServletAutoConfiguration.class, TaskExecutionAutoConfiguration.class,\n		ValidationAutoConfiguration.class })\npublic class WebMvcAutoConfiguration {\n    ...\n}\n```\n\n- 给容器中配置的内容：\n  - 配置文件的相关属性的绑定：WebMvcProperties==**spring.mvc**、ResourceProperties==**spring.resources**\n\n```java\n@Configuration(proxyBeanMethods = false)\n@Import(EnableWebMvcConfiguration.class)\n@EnableConfigurationProperties({ WebMvcProperties.class, ResourceProperties.class })\n@Order(0)\npublic static class WebMvcAutoConfigurationAdapter implements WebMvcConfigurer {\n    ...\n}\n```\n\n### 配置类只有一个有参构造器\n\n```java\n////有参构造器所有参数的值都会从容器中确定\npublic WebMvcAutoConfigurationAdapter(WebProperties webProperties, WebMvcProperties mvcProperties,\n		ListableBeanFactory beanFactory, ObjectProvider<HttpMessageConverters> messageConvertersProvider,\n		ObjectProvider<ResourceHandlerRegistrationCustomizer> resourceHandlerRegistrationCustomizerProvider,\n		ObjectProvider<DispatcherServletPath> dispatcherServletPath,\n		ObjectProvider<ServletRegistrationBean<?>> servletRegistrations) {\n	this.mvcProperties = mvcProperties;\n	this.beanFactory = beanFactory;\n	this.messageConvertersProvider = messageConvertersProvider;\n	this.resourceHandlerRegistrationCustomizer = resourceHandlerRegistrationCustomizerProvider.getIfAvailable();\n	this.dispatcherServletPath = dispatcherServletPath;\n	this.servletRegistrations = servletRegistrations;\n	this.mvcProperties.checkConfiguration();\n}\n```\n\n- ResourceProperties resourceProperties；获取和spring.resources绑定的所有的值的对象\n- WebMvcProperties mvcProperties 获取和spring.mvc绑定的所有的值的对象\n- ListableBeanFactory beanFactory Spring的beanFactory\n- HttpMessageConverters 找到所有的HttpMessageConverters\n- ResourceHandlerRegistrationCustomizer 找到 资源处理器的自定义器。\n- DispatcherServletPath\n- ServletRegistrationBean   给应用注册Servlet、Filter....\n\n### 资源处理的默认规则\n\n```java\n...\npublic class WebMvcAutoConfiguration {\n    ...\n	public static class EnableWebMvcConfiguration extends DelegatingWebMvcConfiguration implements ResourceLoaderAware {\n        ...\n		@Override\n		protected void addResourceHandlers(ResourceHandlerRegistry registry) {\n			super.addResourceHandlers(registry);\n			if (!this.resourceProperties.isAddMappings()) {\n				logger.debug(\"Default resource handling disabled\");\n				return;\n			}\n			ServletContext servletContext = getServletContext();\n			addResourceHandler(registry, \"/webjars/**\", \"classpath:/META-INF/resources/webjars/\");\n			addResourceHandler(registry, this.mvcProperties.getStaticPathPattern(), (registration) -> {\n				registration.addResourceLocations(this.resourceProperties.getStaticLocations());\n				if (servletContext != null) {\n					registration.addResourceLocations(new ServletContextResource(servletContext, SERVLET_LOCATION));\n				}\n			});\n		}\n        ...\n        \n    }\n    ...\n}\n```\n\n根据上述代码，我们可以同过配置禁止所有静态资源规则。\n\n```yaml\nspring:\n  resources:\n    add-mappings: false   #禁用所有静态资源规则\n```\n\n静态资源规则：\n\n```java\n@ConfigurationProperties(prefix = \"spring.resources\", ignoreUnknownFields = false)\npublic class ResourceProperties {\n\n    private static final String[] CLASSPATH_RESOURCE_LOCATIONS = { \"classpath:/META-INF/resources/\",\n            \"classpath:/resources/\", \"classpath:/static/\", \"classpath:/public/\" };\n\n    /**\n     * Locations of static resources. Defaults to classpath:[/META-INF/resources/,\n     * /resources/, /static/, /public/].\n     */\n    private String[] staticLocations = CLASSPATH_RESOURCE_LOCATIONS;\n    ...\n}\n\n```\n\n### 欢迎页的处理规则\n\n```java\n...\npublic class WebMvcAutoConfiguration {\n    ...\n	public static class EnableWebMvcConfiguration extends DelegatingWebMvcConfiguration implements ResourceLoaderAware {\n        ...\n		@Bean\n		public WelcomePageHandlerMapping welcomePageHandlerMapping(ApplicationContext applicationContext,\n				FormattingConversionService mvcConversionService, ResourceUrlProvider mvcResourceUrlProvider) {\n			WelcomePageHandlerMapping welcomePageHandlerMapping = new WelcomePageHandlerMapping(\n					new TemplateAvailabilityProviders(applicationContext), applicationContext, getWelcomePage(),\n					this.mvcProperties.getStaticPathPattern());\n			welcomePageHandlerMapping.setInterceptors(getInterceptors(mvcConversionService, mvcResourceUrlProvider));\n			welcomePageHandlerMapping.setCorsConfigurations(getCorsConfigurations());\n			return welcomePageHandlerMapping;\n		}\n    \n```\n\n`WelcomePageHandlerMapping`的构造方法如下：\n\n```java\nWelcomePageHandlerMapping(TemplateAvailabilityProviders templateAvailabilityProviders,\n                          ApplicationContext applicationContext, Resource welcomePage, String staticPathPattern) {\n    if (welcomePage != null && \"/**\".equals(staticPathPattern)) {\n        //要用欢迎页功能，必须是/**\n        logger.info(\"Adding welcome page: \" + welcomePage);\n        setRootViewName(\"forward:index.html\");\n    }\n    else if (welcomeTemplateExists(templateAvailabilityProviders, applicationContext)) {\n        //调用Controller /index\n        logger.info(\"Adding welcome page template: index\");\n        setRootViewName(\"index\");\n    }\n}\n```\n\n这构造方法内的代码也解释了[web场景-welcome与favicon功能](#)中配置`static-path-pattern`了，welcome页面和小图标失效的问题。\n\n## 26、请求处理-【源码分析】-Rest映射及源码解析\n\n### 请求映射\n\n- @xxxMapping;\n  - @GetMapping\n  - @PostMapping\n  - @PutMapping\n  - @DeleteMapping\n\n- Rest风格支持（使用**HTTP**请求方式动词来表示对资源的操作）\n  - 以前：\n    - /getUser 获取用户\n    - /deleteUser 删除用户\n    - /editUser 修改用户\n    - /saveUser保存用户\n  - 现在： /user \n    - GET-获取用户\n    - DELETE-删除用户\n    - PUT-修改用户\n    - POST-保存用户\n  - 核心Filter；HiddenHttpMethodFilter\n\n- **用法**\n  - 开启页面表单的Rest功能\n  - 页面 form的属性method=post，隐藏域 \\_method=put、delete等（如果直接get或post，无需隐藏域）\n  - 编写请求映射\n\n```yaml\nspring:\n  mvc:\n    hiddenmethod:\n      filter:\n        enabled: true   #开启页面表单的Rest功能\n```\n\n```html\n<form action=\"/user\" method=\"get\">\n    <input value=\"REST-GET提交\" type=\"submit\" />\n</form>\n\n<form action=\"/user\" method=\"post\">\n    <input value=\"REST-POST提交\" type=\"submit\" />\n</form>\n\n<form action=\"/user\" method=\"post\">\n    <input name=\"_method\" type=\"hidden\" value=\"DELETE\"/>\n    <input value=\"REST-DELETE 提交\" type=\"submit\"/>\n</form>\n\n<form action=\"/user\" method=\"post\">\n    <input name=\"_method\" type=\"hidden\" value=\"PUT\" />\n    <input value=\"REST-PUT提交\"type=\"submit\" />\n<form>\n```\n\n```java\n@GetMapping(\"/user\")\n//@RequestMapping(value = \"/user\",method = RequestMethod.GET)\npublic String getUser(){\n    return \"GET-张三\";\n}\n\n@PostMapping(\"/user\")\n//@RequestMapping(value = \"/user\",method = RequestMethod.POST)\npublic String saveUser(){\n    return \"POST-张三\";\n}\n\n@PutMapping(\"/user\")\n//@RequestMapping(value = \"/user\",method = RequestMethod.PUT)\npublic String putUser(){\n    return \"PUT-张三\";\n}\n\n@DeleteMapping(\"/user\")\n//@RequestMapping(value = \"/user\",method = RequestMethod.DELETE)\npublic String deleteUser(){\n    return \"DELETE-张三\";\n}\n```\n\n- Rest原理（表单提交要使用REST的时候）\n  - 表单提交会带上`\\_method=PUT`\n  - **请求过来被**`HiddenHttpMethodFilter`拦截\n    - 请求是否正常，并且是POST\n      - 获取到`\\_method`的值。\n      - 兼容以下请求；**PUT**.**DELETE**.**PATCH**\n      - **原生request（post），包装模式requesWrapper重写了getMethod方法，返回的是传入的值。**\n      - **过滤器链放行的时候用wrapper。以后的方法调用getMethod是调用requesWrapper的。**\n\n```java\npublic class HiddenHttpMethodFilter extends OncePerRequestFilter {\n\n	private static final List<String> ALLOWED_METHODS =\n			Collections.unmodifiableList(Arrays.asList(HttpMethod.PUT.name(),\n					HttpMethod.DELETE.name(), HttpMethod.PATCH.name()));\n\n	/** Default method parameter: {@code _method}. */\n	public static final String DEFAULT_METHOD_PARAM = \"_method\";\n\n	private String methodParam = DEFAULT_METHOD_PARAM;\n\n\n	/**\n	 * Set the parameter name to look for HTTP methods.\n	 * @see #DEFAULT_METHOD_PARAM\n	 */\n	public void setMethodParam(String methodParam) {\n		Assert.hasText(methodParam, \"\'methodParam\' must not be empty\");\n		this.methodParam = methodParam;\n	}\n\n	@Override\n	protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)\n			throws ServletException, IOException {\n\n		HttpServletRequest requestToUse = request;\n\n		if (\"POST\".equals(request.getMethod()) && request.getAttribute(WebUtils.ERROR_EXCEPTION_ATTRIBUTE) == null) {\n			String paramValue = request.getParameter(this.methodParam);\n			if (StringUtils.hasLength(paramValue)) {\n				String method = paramValue.toUpperCase(Locale.ENGLISH);\n				if (ALLOWED_METHODS.contains(method)) {\n					requestToUse = new HttpMethodRequestWrapper(request, method);\n				}\n			}\n		}\n\n		filterChain.doFilter(requestToUse, response);\n	}\n\n\n	/**\n	 * Simple {@link HttpServletRequest} wrapper that returns the supplied method for\n	 * {@link HttpServletRequest#getMethod()}.\n	 */\n	private static class HttpMethodRequestWrapper extends HttpServletRequestWrapper {\n\n		private final String method;\n\n		public HttpMethodRequestWrapper(HttpServletRequest request, String method) {\n			super(request);\n			this.method = method;\n		}\n\n		@Override\n		public String getMethod() {\n			return this.method;\n		}\n	}\n\n}\n```\n\n- Rest使用客户端工具。\n  - 如PostMan可直接发送put、delete等方式请求。\n\n## 27、请求处理-【源码分析】-怎么改变默认的\\_method\n\n```java\n@Configuration(proxyBeanMethods = false)\n@ConditionalOnWebApplication(type = Type.SERVLET)\n@ConditionalOnClass({ Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class })\n@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)\n@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)\n@AutoConfigureAfter({ DispatcherServletAutoConfiguration.class, TaskExecutionAutoConfiguration.class,\n		ValidationAutoConfiguration.class })\npublic class WebMvcAutoConfiguration {\n\n    ...\n    \n    @Bean\n    @ConditionalOnMissingBean(HiddenHttpMethodFilter.class)\n    @ConditionalOnProperty(prefix = \"spring.mvc.hiddenmethod.filter\", name = \"enabled\", matchIfMissing = false)\n    public OrderedHiddenHttpMethodFilter hiddenHttpMethodFilter() {\n        return new OrderedHiddenHttpMethodFilter();\n    }\n    \n    ...\n}\n    \n```\n\n`@ConditionalOnMissingBean(HiddenHttpMethodFilter.class)`意味着在没有`HiddenHttpMethodFilter`时，才执行`hiddenHttpMethodFilter()`。因此，我们可以自定义filter，改变默认的`\\_method`。例如：\n\n```java\n@Configuration(proxyBeanMethods = false)\npublic class WebConfig{\n    //自定义filter\n    @Bean\n    public HiddenHttpMethodFilter hiddenHttpMethodFilter(){\n        HiddenHttpMethodFilter methodFilter = new HiddenHttpMethodFilter();\n        methodFilter.setMethodParam(\"_m\");\n        return methodFilter;\n    }    \n}\n```\n\n将`\\_method`改成`_m`。\n\n```html\n<form action=\"/user\" method=\"post\">\n    <input name=\"_m\" type=\"hidden\" value=\"DELETE\"/>\n    <input value=\"REST-DELETE 提交\" type=\"submit\"/>\n</form>\n```\n\n## 28、请求处理-【源码分析】-请求映射原理\n\n![在这里插入图片描述](image/20210205005703527.png)\nSpringMVC功能分析都从 `org.springframework.web.servlet.DispatcherServlet` -> `doDispatch()`\n\n```java\nprotected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {\n    HttpServletRequest processedRequest = request;\n    HandlerExecutionChain mappedHandler = null;\n    boolean multipartRequestParsed = false;\n\n    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);\n\n    try {\n        ModelAndView mv = null;\n        Exception dispatchException = null;\n\n        try {\n            processedRequest = checkMultipart(request);\n            multipartRequestParsed = (processedRequest != request);\n\n            // 找到当前请求使用哪个Handler（Controller的方法）处理\n            mappedHandler = getHandler(processedRequest);\n\n            //HandlerMapping：处理器映射。/xxx->>xxxx\n    ...\n}\n```\n\n`getHandler()`方法如下：\n\n```java\n@Nullable\nprotected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception {\n    if (this.handlerMappings != null) {\n        for (HandlerMapping mapping : this.handlerMappings) {\n            HandlerExecutionChain handler = mapping.getHandler(request);\n            if (handler != null) {\n                return handler;\n            }\n        }\n    }\n    return null;\n}\n```\n\n`this.handlerMappings`在Debug模式下展现的内容：\n\n![在这里插入图片描述](image/20210205005802305.png)\n其中，保存了所有`@RequestMapping` 和`handler`的映射规则。\n\n![在这里插入图片描述](image/20210205005926474.png)\n\n所有的请求映射都在HandlerMapping中：\n\n- SpringBoot自动配置欢迎页的 WelcomePageHandlerMapping 。访问 /能访问到index.html；\n- SpringBoot自动配置了默认 的 RequestMappingHandlerMapping\n- 请求进来，挨个尝试所有的HandlerMapping看是否有请求信息。\n\n  - 如果有就找到这个请求对应的handler\n  - 如果没有就是下一个 HandlerMapping\n\n- 我们需要一些自定义的映射处理，我们也可以自己给容器中放**HandlerMapping**。自定义 **HandlerMapping**\n\n\n\n---\n\nIDEA快捷键：\n\n- Ctrl + Alt + U : 以UML的类图展现类有哪些继承类，派生类以及实现哪些接口。\n- Crtl + Alt + Shift + U : 同上，区别在于上条快捷键结果在新页展现，而本条快捷键结果在弹窗展现。\n- Ctrl + H : 以树形方式展现类层次结构图。\n\n## 29、请求处理-常用参数注解使用\n\n注解：\n\n- `@PathVariable` 路径变量\n- `@RequestHeader` 获取请求头\n- `@RequestParam` 获取请求参数（指问号后的参数，url?a=1&b=2）\n- `@CookieValue` 获取Cookie值\n- `@RequestAttribute` 获取request域属性\n- `@RequestBody` 获取请求体[POST]\n- `@MatrixVariable` 矩阵变量\n- `@ModelAttribute`\n\n使用用例：\n\n```java\n@RestController\npublic class ParameterTestController {\n\n\n    //  car/2/owner/zhangsan\n    @GetMapping(\"/car/{id}/owner/{username}\")\n    public Map<String,Object> getCar(@PathVariable(\"id\") Integer id,\n                                     @PathVariable(\"username\") String name,\n                                     @PathVariable Map<String,String> pv,\n                                     @RequestHeader(\"User-Agent\") String userAgent,\n                                     @RequestHeader Map<String,String> header,\n                                     @RequestParam(\"age\") Integer age,\n                                     @RequestParam(\"inters\") List<String> inters,\n                                     @RequestParam Map<String,String> params,\n                                     @CookieValue(\"_ga\") String _ga,\n                                     @CookieValue(\"_ga\") Cookie cookie){\n\n        Map<String,Object> map = new HashMap<>();\n\n//        map.put(\"id\",id);\n//        map.put(\"name\",name);\n//        map.put(\"pv\",pv);\n//        map.put(\"userAgent\",userAgent);\n//        map.put(\"headers\",header);\n        map.put(\"age\",age);\n        map.put(\"inters\",inters);\n        map.put(\"params\",params);\n        map.put(\"_ga\",_ga);\n        System.out.println(cookie.getName()+\"===>\"+cookie.getValue());\n        return map;\n    }\n\n\n    @PostMapping(\"/save\")\n    public Map postMethod(@RequestBody String content){\n        Map<String,Object> map = new HashMap<>();\n        map.put(\"content\",content);\n        return map;\n    }\n}\n```\n\n## 30、请求处理-@RequestAttribute\n\n用例：\n\n```java\n@Controller\npublic class RequestController {\n\n    @GetMapping(\"/goto\")\n    public String goToPage(HttpServletRequest request){\n\n        request.setAttribute(\"msg\",\"成功了...\");\n        request.setAttribute(\"code\",200);\n        return \"forward:/success\";  //转发到  /success请求\n    }\n\n    @GetMapping(\"/params\")\n    public String testParam(Map<String,Object> map,\n                            Model model,\n                            HttpServletRequest request,\n                            HttpServletResponse response){\n        map.put(\"hello\",\"world666\");\n        model.addAttribute(\"world\",\"hello666\");\n        request.setAttribute(\"message\",\"HelloWorld\");\n\n        Cookie cookie = new Cookie(\"c1\",\"v1\");\n        response.addCookie(cookie);\n        return \"forward:/success\";\n    }\n\n    ///<-----------------主角@RequestAttribute在这个方法\n    @ResponseBody\n    @GetMapping(\"/success\")\n    public Map success(@RequestAttribute(value = \"msg\",required = false) String msg,\n                       @RequestAttribute(value = \"code\",required = false)Integer code,\n                       HttpServletRequest request){\n        Object msg1 = request.getAttribute(\"msg\");\n\n        Map<String,Object> map = new HashMap<>();\n        Object hello = request.getAttribute(\"hello\");\n        Object world = request.getAttribute(\"world\");\n        Object message = request.getAttribute(\"message\");\n\n        map.put(\"reqMethod_msg\",msg1);\n        map.put(\"annotation_msg\",msg);\n        map.put(\"hello\",hello);\n        map.put(\"world\",world);\n        map.put(\"message\",message);\n\n        return map;\n    }\n}\n```\n\n## 31、请求处理-@MatrixVariable与UrlPathHelper\n\n1. 语法： 请求路径：`/cars/sell;low=34;brand=byd,audi,yd`\n\n2. SpringBoot默认是禁用了矩阵变量的功能\n   - 手动开启：原理。对于路径的处理。UrlPathHelper的removeSemicolonContent设置为false，让其支持矩阵变量的。\n\n3. 矩阵变量**必须**有url路径变量才能被解析\n\n\n\n**手动开启矩阵变量**：\n\n- 实现`WebMvcConfigurer`接口：\n\n```java\n@Configuration(proxyBeanMethods = false)\npublic class WebConfig implements WebMvcConfigurer {\n    @Override\n    public void configurePathMatch(PathMatchConfigurer configurer) {\n\n        UrlPathHelper urlPathHelper = new UrlPathHelper();\n        // 不移除；后面的内容。矩阵变量功能就可以生效\n        urlPathHelper.setRemoveSemicolonContent(false);\n        configurer.setUrlPathHelper(urlPathHelper);\n    }\n}\n```\n\n- 创建返回`WebMvcConfigurer`Bean：\n\n```java\n@Configuration(proxyBeanMethods = false)\npublic class WebConfig{\n    @Bean\n    public WebMvcConfigurer webMvcConfigurer(){\n        return new WebMvcConfigurer() {\n                        @Override\n            public void configurePathMatch(PathMatchConfigurer configurer) {\n                UrlPathHelper urlPathHelper = new UrlPathHelper();\n                // 不移除；后面的内容。矩阵变量功能就可以生效\n                urlPathHelper.setRemoveSemicolonContent(false);\n                configurer.setUrlPathHelper(urlPathHelper);\n            }\n        }\n    }\n}\n```\n\n\n\n**`@MatrixVariable`的用例**\n\n```java\n@RestController\npublic class ParameterTestController {\n\n    ///cars/sell;low=34;brand=byd,audi,yd\n    @GetMapping(\"/cars/{path}\")\n    public Map carsSell(@MatrixVariable(\"low\") Integer low,\n                        @MatrixVariable(\"brand\") List<String> brand,\n                        @PathVariable(\"path\") String path){\n        Map<String,Object> map = new HashMap<>();\n\n        map.put(\"low\",low);\n        map.put(\"brand\",brand);\n        map.put(\"path\",path);\n        return map;\n    }\n\n    // /boss/1;age=20/2;age=10\n\n    @GetMapping(\"/boss/{bossId}/{empId}\")\n    public Map boss(@MatrixVariable(value = \"age\",pathVar = \"bossId\") Integer bossAge,\n                    @MatrixVariable(value = \"age\",pathVar = \"empId\") Integer empAge){\n        Map<String,Object> map = new HashMap<>();\n\n        map.put(\"bossAge\",bossAge);\n        map.put(\"empAge\",empAge);\n        return map;\n\n    }\n\n}\n```\n\n\n\n## 32、请求处理-【源码分析】-各种类型参数解析原理\n\n这要从`DispatcherServlet`开始说起：\n\n```java\npublic class DispatcherServlet extends FrameworkServlet {\n    \n    protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {\n        HttpServletRequest processedRequest = request;\n        HandlerExecutionChain mappedHandler = null;\n        boolean multipartRequestParsed = false;\n\n        WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);\n\n        try {\n            ModelAndView mv = null;\n            Exception dispatchException = null;\n\n            try {\n                processedRequest = checkMultipart(request);\n                multipartRequestParsed = (processedRequest != request);\n\n                // Determine handler for the current request.\n                mappedHandler = getHandler(processedRequest);\n                if (mappedHandler == null) {\n                    noHandlerFound(processedRequest, response);\n                    return;\n                }\n\n                // Determine handler adapter for the current request.\n                HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());\n                ...\n```\n\n- `HandlerMapping`中找到能处理请求的`Handler`（Controller.method()）。\n- 为当前Handler 找一个适配器 `HandlerAdapter`，用的最多的是**RequestMappingHandlerAdapter**。\n- 适配器执行目标方法并确定方法参数的每一个值。\n\n### HandlerAdapter\n\n默认会加载所有`HandlerAdapter`\n\n```java\npublic class DispatcherServlet extends FrameworkServlet {\n\n    /** Detect all HandlerAdapters or just expect \"handlerAdapter\" bean?. */\n    private boolean detectAllHandlerAdapters = true;\n\n    ...\n    \n    private void initHandlerAdapters(ApplicationContext context) {\n        this.handlerAdapters = null;\n\n        if (this.detectAllHandlerAdapters) {\n            // Find all HandlerAdapters in the ApplicationContext, including ancestor contexts.\n            Map<String, HandlerAdapter> matchingBeans =\n                BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerAdapter.class, true, false);\n            if (!matchingBeans.isEmpty()) {\n                this.handlerAdapters = new ArrayList<>(matchingBeans.values());\n                // We keep HandlerAdapters in sorted order.\n                AnnotationAwareOrderComparator.sort(this.handlerAdapters);\n            }\n        }\n     ...\n```\n\n有这些`HandlerAdapter`：\n\n![在这里插入图片描述](image/20210205010047654.png)\n\n\n0. 支持方法上标注`@RequestMapping` \n\n1. 支持函数式编程的\n2. ...\n3. ...\n\n### 执行目标方法\n\n```java\npublic class DispatcherServlet extends FrameworkServlet {\n    \n	protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {\n        ModelAndView mv = null;\n        \n        ...\n\n        // Determine handler for the current request.\n        mappedHandler = getHandler(processedRequest);\n        if (mappedHandler == null) {\n            noHandlerFound(processedRequest, response);\n            return;\n        }\n\n        // Determine handler adapter for the current request.\n        HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());\n\n        ...\n		//本节重点\n        // Actually invoke the handler.\n        mv = ha.handle(processedRequest, response, mappedHandler.getHandler());\n```\n\n`HandlerAdapter`接口实现类`RequestMappingHandlerAdapter`（主要用来处理`@RequestMapping`）\n\n```java\npublic class RequestMappingHandlerAdapter extends AbstractHandlerMethodAdapter\n		implements BeanFactoryAware, InitializingBean {\n\n    ...\n    \n    //AbstractHandlerMethodAdapter类的方法，RequestMappingHandlerAdapter继承AbstractHandlerMethodAdapter\n	public final ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler)\n        throws Exception {\n\n        return handleInternal(request, response, (HandlerMethod) handler);\n    }\n\n	@Override\n	protected ModelAndView handleInternal(HttpServletRequest request,\n			HttpServletResponse response, HandlerMethod handlerMethod) throws Exception {\n    	ModelAndView mav;\n        //handleInternal的核心\n        mav = invokeHandlerMethod(request, response, handlerMethod);//解释看下节\n		//...\n		return mav;\n    }\n}\n```\n\n### 参数解析器\n\n确定将要执行的目标方法的每一个参数的值是什么;\n\nSpringMVC目标方法能写多少种参数类型。取决于**参数解析器argumentResolvers**。\n\n```java\n@Nullable\nprotected ModelAndView invokeHandlerMethod(HttpServletRequest request,\n                                           HttpServletResponse response, HandlerMethod handlerMethod) throws Exception {\n\n    ServletWebRequest webRequest = new ServletWebRequest(request, response);\n    try {\n        WebDataBinderFactory binderFactory = getDataBinderFactory(handlerMethod);\n        ModelFactory modelFactory = getModelFactory(handlerMethod, binderFactory);\n\n        ServletInvocableHandlerMethod invocableMethod = createInvocableHandlerMethod(handlerMethod);\n        if (this.argumentResolvers != null) {//<-----关注点\n            invocableMethod.setHandlerMethodArgumentResolvers(this.argumentResolvers);\n        }\n        \n        ...\n```\n\n`this.argumentResolvers`在`afterPropertiesSet()`方法内初始化\n\n```java\npublic class RequestMappingHandlerAdapter extends AbstractHandlerMethodAdapter\n		implements BeanFactoryAware, InitializingBean {\n	\n    @Nullable\n    private HandlerMethodArgumentResolverComposite argumentResolvers;\n    \n    @Override\n    public void afterPropertiesSet() {\n        ...\n    	if (this.argumentResolvers == null) {//初始化argumentResolvers\n        	List<HandlerMethodArgumentResolver> resolvers = getDefaultArgumentResolvers();\n            this.argumentResolvers = new HandlerMethodArgumentResolverComposite().addResolvers(resolvers);\n        }\n        ...\n    }\n\n    //初始化了一堆的实现HandlerMethodArgumentResolver接口的\n	private List<HandlerMethodArgumentResolver> getDefaultArgumentResolvers() {\n		List<HandlerMethodArgumentResolver> resolvers = new ArrayList<>(30);\n\n		// Annotation-based argument resolution\n		resolvers.add(new RequestParamMethodArgumentResolver(getBeanFactory(), false));\n		resolvers.add(new RequestParamMapMethodArgumentResolver());\n		resolvers.add(new PathVariableMethodArgumentResolver());\n		resolvers.add(new PathVariableMapMethodArgumentResolver());\n		resolvers.add(new MatrixVariableMethodArgumentResolver());\n		resolvers.add(new MatrixVariableMapMethodArgumentResolver());\n		resolvers.add(new ServletModelAttributeMethodProcessor(false));\n		resolvers.add(new RequestResponseBodyMethodProcessor(getMessageConverters(), this.requestResponseBodyAdvice));\n		resolvers.add(new RequestPartMethodArgumentResolver(getMessageConverters(), this.requestResponseBodyAdvice));\n		resolvers.add(new RequestHeaderMethodArgumentResolver(getBeanFactory()));\n		resolvers.add(new RequestHeaderMapMethodArgumentResolver());\n		resolvers.add(new ServletCookieValueMethodArgumentResolver(getBeanFactory()));\n		resolvers.add(new ExpressionValueMethodArgumentResolver(getBeanFactory()));\n		resolvers.add(new SessionAttributeMethodArgumentResolver());\n		resolvers.add(new RequestAttributeMethodArgumentResolver());\n\n		// Type-based argument resolution\n		resolvers.add(new ServletRequestMethodArgumentResolver());\n		resolvers.add(new ServletResponseMethodArgumentResolver());\n		resolvers.add(new HttpEntityMethodProcessor(getMessageConverters(), this.requestResponseBodyAdvice));\n		resolvers.add(new RedirectAttributesMethodArgumentResolver());\n		resolvers.add(new ModelMethodProcessor());\n		resolvers.add(new MapMethodProcessor());\n		resolvers.add(new ErrorsMethodArgumentResolver());\n		resolvers.add(new SessionStatusMethodArgumentResolver());\n		resolvers.add(new UriComponentsBuilderMethodArgumentResolver());\n		if (KotlinDetector.isKotlinPresent()) {\n			resolvers.add(new ContinuationHandlerMethodArgumentResolver());\n		}\n\n		// Custom arguments\n		if (getCustomArgumentResolvers() != null) {\n			resolvers.addAll(getCustomArgumentResolvers());\n		}\n\n		// Catch-all\n		resolvers.add(new PrincipalMethodArgumentResolver());\n		resolvers.add(new RequestParamMethodArgumentResolver(getBeanFactory(), true));\n		resolvers.add(new ServletModelAttributeMethodProcessor(true));\n\n		return resolvers;\n	}\n    \n}\n```\n\n`HandlerMethodArgumentResolverComposite`类如下：（众多**参数解析器argumentResolvers**的包装类）。\n\n```java\npublic class HandlerMethodArgumentResolverComposite implements HandlerMethodArgumentResolver {\n\n	private final List<HandlerMethodArgumentResolver> argumentResolvers = new ArrayList<>();\n    \n    ...\n    \n	public HandlerMethodArgumentResolverComposite addResolvers(\n			@Nullable HandlerMethodArgumentResolver... resolvers) {\n\n		if (resolvers != null) {\n			Collections.addAll(this.argumentResolvers, resolvers);\n		}\n		return this;\n	}\n    \n    ...\n}\n```\n\n我们看看`HandlerMethodArgumentResolver`的源码：\n\n```java\npublic interface HandlerMethodArgumentResolver {\n\n    //当前解析器是否支持解析这种参数\n	boolean supportsParameter(MethodParameter parameter);\n\n	@Nullable//如果支持，就调用 resolveArgument\n	Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,\n			NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception;\n\n}\n\n```\n\n### 返回值处理器\n\n**ValueHandler**\n\n```java\n@Nullable\nprotected ModelAndView invokeHandlerMethod(HttpServletRequest request,\n                                           HttpServletResponse response, HandlerMethod handlerMethod) throws Exception {\n\n    ServletWebRequest webRequest = new ServletWebRequest(request, response);\n    try {\n        WebDataBinderFactory binderFactory = getDataBinderFactory(handlerMethod);\n        ModelFactory modelFactory = getModelFactory(handlerMethod, binderFactory);\n\n        ServletInvocableHandlerMethod invocableMethod = createInvocableHandlerMethod(handlerMethod);\n        if (this.argumentResolvers != null) {\n            invocableMethod.setHandlerMethodArgumentResolvers(this.argumentResolvers);\n        }\n        if (this.returnValueHandlers != null) {//<---关注点\n            invocableMethod.setHandlerMethodReturnValueHandlers(this.returnValueHandlers);\n        }\n     ...\n\n```\n\n`this.returnValueHandlers`在`afterPropertiesSet()`方法内初始化\n\n```java\npublic class RequestMappingHandlerAdapter extends AbstractHandlerMethodAdapter\n		implements BeanFactoryAware, InitializingBean {\n	\n	@Nullable\n	private HandlerMethodReturnValueHandlerComposite returnValueHandlers;\n    \n	@Override\n	public void afterPropertiesSet() {\n\n        ...\n        \n		if (this.returnValueHandlers == null) {\n			List<HandlerMethodReturnValueHandler> handlers = getDefaultReturnValueHandlers();\n			this.returnValueHandlers = new HandlerMethodReturnValueHandlerComposite().addHandlers(handlers);\n		}\n	}\n    \n    //初始化了一堆的实现HandlerMethodReturnValueHandler接口的\n    private List<HandlerMethodReturnValueHandler> getDefaultReturnValueHandlers() {\n		List<HandlerMethodReturnValueHandler> handlers = new ArrayList<>(20);\n\n		// Single-purpose return value types\n		handlers.add(new ModelAndViewMethodReturnValueHandler());\n		handlers.add(new ModelMethodProcessor());\n		handlers.add(new ViewMethodReturnValueHandler());\n		handlers.add(new ResponseBodyEmitterReturnValueHandler(getMessageConverters(),\n				this.reactiveAdapterRegistry, this.taskExecutor, this.contentNegotiationManager));\n		handlers.add(new StreamingResponseBodyReturnValueHandler());\n		handlers.add(new HttpEntityMethodProcessor(getMessageConverters(),\n				this.contentNegotiationManager, this.requestResponseBodyAdvice));\n		handlers.add(new HttpHeadersReturnValueHandler());\n		handlers.add(new CallableMethodReturnValueHandler());\n		handlers.add(new DeferredResultMethodReturnValueHandler());\n		handlers.add(new AsyncTaskMethodReturnValueHandler(this.beanFactory));\n\n		// Annotation-based return value types\n		handlers.add(new ServletModelAttributeMethodProcessor(false));\n		handlers.add(new RequestResponseBodyMethodProcessor(getMessageConverters(),\n				this.contentNegotiationManager, this.requestResponseBodyAdvice));\n\n		// Multi-purpose return value types\n		handlers.add(new ViewNameMethodReturnValueHandler());\n		handlers.add(new MapMethodProcessor());\n\n		// Custom return value types\n		if (getCustomReturnValueHandlers() != null) {\n			handlers.addAll(getCustomReturnValueHandlers());\n		}\n\n		// Catch-all\n		if (!CollectionUtils.isEmpty(getModelAndViewResolvers())) {\n			handlers.add(new ModelAndViewResolverMethodReturnValueHandler(getModelAndViewResolvers()));\n		}\n		else {\n			handlers.add(new ServletModelAttributeMethodProcessor(true));\n		}\n\n		return handlers;\n	}\n}\n```\n\n`HandlerMethodReturnValueHandlerComposite`类如下：\n\n```java\npublic class HandlerMethodReturnValueHandlerComposite implements HandlerMethodReturnValueHandler {\n\n	private final List<HandlerMethodReturnValueHandler> returnValueHandlers = new ArrayList<>();\n\n    ...\n    \n	public HandlerMethodReturnValueHandlerComposite addHandlers(\n			@Nullable List<? extends HandlerMethodReturnValueHandler> handlers) {\n\n		if (handlers != null) {\n			this.returnValueHandlers.addAll(handlers);\n		}\n		return this;\n	}\n\n}\n```\n\n`HandlerMethodReturnValueHandler`接口：\n\n```java\npublic interface HandlerMethodReturnValueHandler {\n\n	boolean supportsReturnType(MethodParameter returnType);\n\n	void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType,\n			ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception;\n\n}\n```\n\n### 回顾执行目标方法\n\n```java\npublic class DispatcherServlet extends FrameworkServlet {\n    ...\n	protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {\n        ModelAndView mv = null;\n		...\n        mv = ha.handle(processedRequest, response, mappedHandler.getHandler());\n```\n\n`RequestMappingHandlerAdapter`的`handle()`方法：\n\n```java\npublic class RequestMappingHandlerAdapter extends AbstractHandlerMethodAdapter\n		implements BeanFactoryAware, InitializingBean {\n\n    ...\n    \n    //AbstractHandlerMethodAdapter类的方法，RequestMappingHandlerAdapter继承AbstractHandlerMethodAdapter\n	public final ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler)\n        throws Exception {\n\n        return handleInternal(request, response, (HandlerMethod) handler);\n    }\n\n	@Override\n	protected ModelAndView handleInternal(HttpServletRequest request,\n			HttpServletResponse response, HandlerMethod handlerMethod) throws Exception {\n    	ModelAndView mav;\n        //handleInternal的核心\n        mav = invokeHandlerMethod(request, response, handlerMethod);//解释看下节\n		//...\n		return mav;\n    }\n}\n```\n\n`RequestMappingHandlerAdapter`的`invokeHandlerMethod()`方法：\n\n```java\npublic class RequestMappingHandlerAdapter extends AbstractHandlerMethodAdapter\n		implements BeanFactoryAware, InitializingBean {\n    \n	protected ModelAndView invokeHandlerMethod(HttpServletRequest request,\n			HttpServletResponse response, HandlerMethod handlerMethod) throws Exception {\n\n		ServletWebRequest webRequest = new ServletWebRequest(request, response);\n		try {\n			...\n            \n            ServletInvocableHandlerMethod invocableMethod = createInvocableHandlerMethod(handlerMethod);\n			if (this.argumentResolvers != null) {\n				invocableMethod.setHandlerMethodArgumentResolvers(this.argumentResolvers);\n			}\n			if (this.returnValueHandlers != null) {\n				invocableMethod.setHandlerMethodReturnValueHandlers(this.returnValueHandlers);\n			}\n			...\n\n            //关注点：执行目标方法\n			invocableMethod.invokeAndHandle(webRequest, mavContainer);\n			if (asyncManager.isConcurrentHandlingStarted()) {\n				return null;\n			}\n\n			return getModelAndView(mavContainer, modelFactory, webRequest);\n		}\n		finally {\n			webRequest.requestCompleted();\n		}\n	}\n```\n\n`invokeAndHandle()`方法如下：\n\n```java\npublic class ServletInvocableHandlerMethod extends InvocableHandlerMethod {\n\n	public void invokeAndHandle(ServletWebRequest webRequest, ModelAndViewContainer mavContainer,\n			Object... providedArgs) throws Exception {\n\n		Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs);\n\n        ...\n        \n		try {\n            //returnValue存储起来\n			this.returnValueHandlers.handleReturnValue(\n					returnValue, getReturnValueType(returnValue), mavContainer, webRequest);\n		}\n		catch (Exception ex) {\n			...\n		}\n	}\n    \n    @Nullable//InvocableHandlerMethod类的，ServletInvocableHandlerMethod类继承InvocableHandlerMethod类\n	public Object invokeForRequest(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer,\n			Object... providedArgs) throws Exception {\n\n        ////获取方法的参数值\n		Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs);\n\n        ...\n       \n		return doInvoke(args);\n	}\n\n    @Nullable\n	protected Object doInvoke(Object... args) throws Exception {\n		Method method = getBridgedMethod();//@RequestMapping的方法\n		ReflectionUtils.makeAccessible(method);\n		try {\n			if (KotlinDetector.isSuspendingFunction(method)) {\n				return CoroutinesUtils.invokeSuspendingFunction(method, getBean(), args);\n			}\n            //通过反射调用\n			return method.invoke(getBean(), args);//getBean()指@RequestMapping的方法所在类的对象。\n		}\n		catch (IllegalArgumentException ex) {\n			...\n		}\n		catch (InvocationTargetException ex) {\n			...\n		}\n	}\n    \n}   \n```\n\n\n\n### 如何确定目标方法每一个参数的值\n\n重点分析`ServletInvocableHandlerMethod`的`getMethodArgumentValues`方法\n\n```java\npublic class ServletInvocableHandlerMethod extends InvocableHandlerMethod {\n    ...\n\n	@Nullable//InvocableHandlerMethod类的，ServletInvocableHandlerMethod类继承InvocableHandlerMethod类\n	public Object invokeForRequest(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer,\n			Object... providedArgs) throws Exception {\n\n        ////获取方法的参数值\n		Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs);\n\n        ...\n       \n		return doInvoke(args);\n	}\n \n    //本节重点，获取方法的参数值\n	protected Object[] getMethodArgumentValues(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer,\n			Object... providedArgs) throws Exception {\n\n		MethodParameter[] parameters = getMethodParameters();\n		if (ObjectUtils.isEmpty(parameters)) {\n			return EMPTY_ARGS;\n		}\n\n		Object[] args = new Object[parameters.length];\n		for (int i = 0; i < parameters.length; i++) {\n			MethodParameter parameter = parameters[i];\n			parameter.initParameterNameDiscovery(this.parameterNameDiscoverer);\n			args[i] = findProvidedArgument(parameter, providedArgs);\n			if (args[i] != null) {\n				continue;\n			}\n            //查看resolvers是否有支持\n			if (!this.resolvers.supportsParameter(parameter)) {\n				throw new IllegalStateException(formatArgumentError(parameter, \"No suitable resolver\"));\n			}\n			try {\n                //支持的话就开始解析吧\n				args[i] = this.resolvers.resolveArgument(parameter, mavContainer, request, this.dataBinderFactory);\n			}\n			catch (Exception ex) {\n				....\n			}\n		}\n		return args;\n	}\n    \n}\n```\n\n`this.resolvers`的类型为`HandlerMethodArgumentResolverComposite`（在[参数解析器](#)章节提及）\n\n```java\npublic class HandlerMethodArgumentResolverComposite implements HandlerMethodArgumentResolver {\n    \n	@Override\n	public boolean supportsParameter(MethodParameter parameter) {\n		return getArgumentResolver(parameter) != null;\n	}\n\n	@Override\n	@Nullable\n	public Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,\n			NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception {\n\n		HandlerMethodArgumentResolver resolver = getArgumentResolver(parameter);\n		if (resolver == null) {\n			throw new IllegalArgumentException(\"Unsupported parameter type [\" +\n					parameter.getParameterType().getName() + \"]. supportsParameter should be called first.\");\n		}\n		return resolver.resolveArgument(parameter, mavContainer, webRequest, binderFactory);\n	}\n    \n    \n    @Nullable\n	private HandlerMethodArgumentResolver getArgumentResolver(MethodParameter parameter) {\n		HandlerMethodArgumentResolver result = this.argumentResolverCache.get(parameter);\n		if (result == null) {\n            //挨个判断所有参数解析器那个支持解析这个参数\n			for (HandlerMethodArgumentResolver resolver : this.argumentResolvers) {\n				if (resolver.supportsParameter(parameter)) {\n					result = resolver;\n					this.argumentResolverCache.put(parameter, result);//找到了，resolver就缓存起来，方便稍后resolveArgument()方法使用\n					break;\n				}\n			}\n		}\n		return result;\n	}\n}\n```\n\n### 小结\n\n本节描述，一个请求发送到DispatcherServlet后的具体处理流程，也就是SpringMVC的主要原理。\n\n本节内容较多且硬核，对日后编程很有帮助，需耐心对待。\n\n可以运行一个示例，打断点，在Debug模式下，查看程序流程。\n\n## 33、请求处理-【源码分析】-Servlet API参数解析原理\n\n- WebRequest\n- ServletRequest\n- MultipartRequest\n- HttpSession\n- javax.servlet.http.PushBuilder\n- Principal\n- InputStream\n- Reader\n- HttpMethod\n- Locale\n- TimeZone\n- ZoneId\n\n**ServletRequestMethodArgumentResolver**用来处理以上的参数\n\n```java\npublic class ServletRequestMethodArgumentResolver implements HandlerMethodArgumentResolver {\n\n	@Nullable\n	private static Class<?> pushBuilder;\n\n	static {\n		try {\n			pushBuilder = ClassUtils.forName(\"javax.servlet.http.PushBuilder\",\n					ServletRequestMethodArgumentResolver.class.getClassLoader());\n		}\n		catch (ClassNotFoundException ex) {\n			// Servlet 4.0 PushBuilder not found - not supported for injection\n			pushBuilder = null;\n		}\n	}\n\n\n	@Override\n	public boolean supportsParameter(MethodParameter parameter) {\n		Class<?> paramType = parameter.getParameterType();\n		return (WebRequest.class.isAssignableFrom(paramType) ||\n				ServletRequest.class.isAssignableFrom(paramType) ||\n				MultipartRequest.class.isAssignableFrom(paramType) ||\n				HttpSession.class.isAssignableFrom(paramType) ||\n				(pushBuilder != null && pushBuilder.isAssignableFrom(paramType)) ||\n				(Principal.class.isAssignableFrom(paramType) && !parameter.hasParameterAnnotations()) ||\n				InputStream.class.isAssignableFrom(paramType) ||\n				Reader.class.isAssignableFrom(paramType) ||\n				HttpMethod.class == paramType ||\n				Locale.class == paramType ||\n				TimeZone.class == paramType ||\n				ZoneId.class == paramType);\n	}\n\n	@Override\n	public Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,\n			NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception {\n\n		Class<?> paramType = parameter.getParameterType();\n\n		// WebRequest / NativeWebRequest / ServletWebRequest\n		if (WebRequest.class.isAssignableFrom(paramType)) {\n			if (!paramType.isInstance(webRequest)) {\n				throw new IllegalStateException(\n						\"Current request is not of type [\" + paramType.getName() + \"]: \" + webRequest);\n			}\n			return webRequest;\n		}\n\n		// ServletRequest / HttpServletRequest / MultipartRequest / MultipartHttpServletRequest\n		if (ServletRequest.class.isAssignableFrom(paramType) || MultipartRequest.class.isAssignableFrom(paramType)) {\n			return resolveNativeRequest(webRequest, paramType);\n		}\n\n		// HttpServletRequest required for all further argument types\n		return resolveArgument(paramType, resolveNativeRequest(webRequest, HttpServletRequest.class));\n	}\n\n	private <T> T resolveNativeRequest(NativeWebRequest webRequest, Class<T> requiredType) {\n		T nativeRequest = webRequest.getNativeRequest(requiredType);\n		if (nativeRequest == null) {\n			throw new IllegalStateException(\n					\"Current request is not of type [\" + requiredType.getName() + \"]: \" + webRequest);\n		}\n		return nativeRequest;\n	}\n\n	@Nullable\n	private Object resolveArgument(Class<?> paramType, HttpServletRequest request) throws IOException {\n		if (HttpSession.class.isAssignableFrom(paramType)) {\n			HttpSession session = request.getSession();\n			if (session != null && !paramType.isInstance(session)) {\n				throw new IllegalStateException(\n						\"Current session is not of type [\" + paramType.getName() + \"]: \" + session);\n			}\n			return session;\n		}\n		else if (pushBuilder != null && pushBuilder.isAssignableFrom(paramType)) {\n			return PushBuilderDelegate.resolvePushBuilder(request, paramType);\n		}\n		else if (InputStream.class.isAssignableFrom(paramType)) {\n			InputStream inputStream = request.getInputStream();\n			if (inputStream != null && !paramType.isInstance(inputStream)) {\n				throw new IllegalStateException(\n						\"Request input stream is not of type [\" + paramType.getName() + \"]: \" + inputStream);\n			}\n			return inputStream;\n		}\n		else if (Reader.class.isAssignableFrom(paramType)) {\n			Reader reader = request.getReader();\n			if (reader != null && !paramType.isInstance(reader)) {\n				throw new IllegalStateException(\n						\"Request body reader is not of type [\" + paramType.getName() + \"]: \" + reader);\n			}\n			return reader;\n		}\n		else if (Principal.class.isAssignableFrom(paramType)) {\n			Principal userPrincipal = request.getUserPrincipal();\n			if (userPrincipal != null && !paramType.isInstance(userPrincipal)) {\n				throw new IllegalStateException(\n						\"Current user principal is not of type [\" + paramType.getName() + \"]: \" + userPrincipal);\n			}\n			return userPrincipal;\n		}\n		else if (HttpMethod.class == paramType) {\n			return HttpMethod.resolve(request.getMethod());\n		}\n		else if (Locale.class == paramType) {\n			return RequestContextUtils.getLocale(request);\n		}\n		else if (TimeZone.class == paramType) {\n			TimeZone timeZone = RequestContextUtils.getTimeZone(request);\n			return (timeZone != null ? timeZone : TimeZone.getDefault());\n		}\n		else if (ZoneId.class == paramType) {\n			TimeZone timeZone = RequestContextUtils.getTimeZone(request);\n			return (timeZone != null ? timeZone.toZoneId() : ZoneId.systemDefault());\n		}\n\n		// Should never happen...\n		throw new UnsupportedOperationException(\"Unknown parameter type: \" + paramType.getName());\n	}\n\n\n	/**\n	 * Inner class to avoid a hard dependency on Servlet API 4.0 at runtime.\n	 */\n	private static class PushBuilderDelegate {\n\n		@Nullable\n		public static Object resolvePushBuilder(HttpServletRequest request, Class<?> paramType) {\n			PushBuilder pushBuilder = request.newPushBuilder();\n			if (pushBuilder != null && !paramType.isInstance(pushBuilder)) {\n				throw new IllegalStateException(\n						\"Current push builder is not of type [\" + paramType.getName() + \"]: \" + pushBuilder);\n			}\n			return pushBuilder;\n\n		}\n	}\n}\n```\n\n用例：\n\n```java\n@Controller\npublic class RequestController {\n\n    @GetMapping(\"/goto\")\n    public String goToPage(HttpServletRequest request){\n\n        request.setAttribute(\"msg\",\"成功了...\");\n        request.setAttribute(\"code\",200);\n        return \"forward:/success\";  //转发到  /success请求\n    }\n}\n```\n\n## 34、请求处理-【源码分析】-Model、Map原理\n\n复杂参数：\n\n- **Map**\n- **Model（map、model里面的数据会被放在request的请求域  request.setAttribute）**\n- Errors/BindingResult\n- **RedirectAttributes（ 重定向携带数据）**\n- **ServletResponse（response）**\n- SessionStatus\n\n- UriComponentsBuilder\n- ServletUriComponentsBuilder\n\n用例：\n\n```java\n@GetMapping(\"/params\")\npublic String testParam(Map<String,Object> map,\n                        Model model,\n                        HttpServletRequest request,\n                        HttpServletResponse response){\n    //下面三位都是可以给request域中放数据\n    map.put(\"hello\",\"world666\");\n    model.addAttribute(\"world\",\"hello666\");\n    request.setAttribute(\"message\",\"HelloWorld\");\n\n    Cookie cookie = new Cookie(\"c1\",\"v1\");\n    response.addCookie(cookie);\n    return \"forward:/success\";\n}\n\n@ResponseBody\n@GetMapping(\"/success\")\npublic Map success(@RequestAttribute(value = \"msg\",required = false) String msg,\n                   @RequestAttribute(value = \"code\",required = false)Integer code,\n                   HttpServletRequest request){\n    Object msg1 = request.getAttribute(\"msg\");\n\n    Map<String,Object> map = new HashMap<>();\n    Object hello = request.getAttribute(\"hello\");//得出testParam方法赋予的值 world666\n    Object world = request.getAttribute(\"world\");//得出testParam方法赋予的值 hello666\n    Object message = request.getAttribute(\"message\");//得出testParam方法赋予的值 HelloWorld\n\n    map.put(\"reqMethod_msg\",msg1);\n    map.put(\"annotation_msg\",msg);\n    map.put(\"hello\",hello);\n    map.put(\"world\",world);\n    map.put(\"message\",message);\n\n    return map;\n}\n```\n\n- `Map<String,Object> map`\n\n- `Model model`\n\n- `HttpServletRequest request` \n\n\n上面三位都是可以给request域中放数据，用`request.getAttribute()`获取\n\n接下来我们看看，`Map<String,Object> map`与`Model model`用什么参数处理器。\n\n---\n\n`Map<String,Object> map`参数用`MapMethodProcessor`处理：\n\n```java\npublic class MapMethodProcessor implements HandlerMethodArgumentResolver, HandlerMethodReturnValueHandler {\n\n	@Override\n	public boolean supportsParameter(MethodParameter parameter) {\n		return (Map.class.isAssignableFrom(parameter.getParameterType()) &&\n				parameter.getParameterAnnotations().length == 0);\n	}\n\n	@Override\n	@Nullable\n	public Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,\n			NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception {\n\n		Assert.state(mavContainer != null, \"ModelAndViewContainer is required for model exposure\");\n		return mavContainer.getModel();\n	}\n    \n    ...\n    \n}\n```\n\n`mavContainer.getModel()`如下：\n\n```java\npublic class ModelAndViewContainer {\n\n    ...\n\n	private final ModelMap defaultModel = new BindingAwareModelMap();\n\n	@Nullable\n	private ModelMap redirectModel;\n\n    ...\n\n	public ModelMap getModel() {\n		if (useDefaultModel()) {\n			return this.defaultModel;\n		}\n		else {\n			if (this.redirectModel == null) {\n				this.redirectModel = new ModelMap();\n			}\n			return this.redirectModel;\n		}\n	}\n    \n    private boolean useDefaultModel() {\n		return (!this.redirectModelScenario || (this.redirectModel == null && !this.ignoreDefaultModelOnRedirect));\n	}\n    ...\n    \n}\n```\n\n---\n\n`Model model`用`ModelMethodProcessor`处理：\n\n```java\npublic class ModelMethodProcessor implements HandlerMethodArgumentResolver, HandlerMethodReturnValueHandler {\n\n	@Override\n	public boolean supportsParameter(MethodParameter parameter) {\n		return Model.class.isAssignableFrom(parameter.getParameterType());\n	}\n\n	@Override\n	@Nullable\n	public Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,\n			NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception {\n\n		Assert.state(mavContainer != null, \"ModelAndViewContainer is required for model exposure\");\n		return mavContainer.getModel();\n	}\n    ...\n}\n```\n\n`return mavContainer.getModel();`这跟`MapMethodProcessor`的一致\n\n![在这里插入图片描述](image/20210205010247689.png)\n\n\n`Model`也是另一种意义的`Map`。\n\n---\n\n**接下来看看**`Map<String,Object> map`与`Model model`值是如何做到用`request.getAttribute()`获取的。\n\n众所周知，所有的数据都放在 **ModelAndView**包含要去的页面地址View，还包含Model数据。\n\n先看**ModelAndView**接下来是如何处理的？\n\n```java\npublic class DispatcherServlet extends FrameworkServlet {\n    \n    ...\n    \n	protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {\n		...\n\n		try {\n			ModelAndView mv = null;\n            \n            ...\n\n			// Actually invoke the handler.\n			mv = ha.handle(processedRequest, response, mappedHandler.getHandler());\n            \n            ...\n            \n			}\n			catch (Exception ex) {\n				dispatchException = ex;\n			}\n			catch (Throwable err) {\n				// As of 4.3, we\'re processing Errors thrown from handler methods as well,\n				// making them available for @ExceptionHandler methods and other scenarios.\n				dispatchException = new NestedServletException(\"Handler dispatch failed\", err);\n			}\n        	//处理分发结果\n			processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);\n		}\n        ...\n\n	}\n\n	private void processDispatchResult(HttpServletRequest request, HttpServletResponse response,\n			@Nullable HandlerExecutionChain mappedHandler, @Nullable ModelAndView mv,\n			@Nullable Exception exception) throws Exception {\n        ...\n\n		// Did the handler return a view to render?\n		if (mv != null && !mv.wasCleared()) {\n			render(mv, request, response);\n			...\n		}\n		...\n	}\n\n	protected void render(ModelAndView mv, HttpServletRequest request, HttpServletResponse response) throws Exception {\n		...\n\n		View view;\n		String viewName = mv.getViewName();\n		if (viewName != null) {\n			// We need to resolve the view name.\n			view = resolveViewName(viewName, mv.getModelInternal(), locale, request);\n			if (view == null) {\n				throw new ServletException(\"Could not resolve view with name \'\" + mv.getViewName() +\n						\"\' in servlet with name \'\" + getServletName() + \"\'\");\n			}\n		}\n		else {\n			// No need to lookup: the ModelAndView object contains the actual View object.\n			view = mv.getView();\n			if (view == null) {\n				throw new ServletException(\"ModelAndView [\" + mv + \"] neither contains a view name nor a \" +\n						\"View object in servlet with name \'\" + getServletName() + \"\'\");\n			}\n		}\n		view.render(mv.getModelInternal(), request, response);\n        \n        ...\n	}\n\n}\n```\n\n在Debug模式下，`view`属为`InternalResourceView`类。\n\n```java\npublic class InternalResourceView extends AbstractUrlBasedView {\n    \n 	@Override//该方法在AbstractView，AbstractUrlBasedView继承了AbstractView\n	public void render(@Nullable Map<String, ?> model, HttpServletRequest request,\n			HttpServletResponse response) throws Exception {\n		\n        ...\n        \n		Map<String, Object> mergedModel = createMergedOutputModel(model, request, response);\n		prepareResponse(request, response);\n        \n        //看下一个方法实现\n		renderMergedOutputModel(mergedModel, getRequestToExpose(request), response);\n	}\n    \n    @Override\n	protected void renderMergedOutputModel(\n			Map<String, Object> model, HttpServletRequest request, HttpServletResponse response) throws Exception {\n\n		// Expose the model object as request attributes.\n        // 暴露模型作为请求域属性\n		exposeModelAsRequestAttributes(model, request);//<---重点\n\n		// Expose helpers as request attributes, if any.\n		exposeHelpers(request);\n\n		// Determine the path for the request dispatcher.\n		String dispatcherPath = prepareForRendering(request, response);\n\n		// Obtain a RequestDispatcher for the target resource (typically a JSP).\n		RequestDispatcher rd = getRequestDispatcher(request, dispatcherPath);\n		\n        ...\n	}\n    \n    //该方法在AbstractView，AbstractUrlBasedView继承了AbstractView\n    protected void exposeModelAsRequestAttributes(Map<String, Object> model,\n			HttpServletRequest request) throws Exception {\n\n		model.forEach((name, value) -> {\n			if (value != null) {\n				request.setAttribute(name, value);\n			}\n			else {\n				request.removeAttribute(name);\n			}\n		});\n	}\n    \n}\n```\n\n`exposeModelAsRequestAttributes`方法看出，`Map<String,Object> map`，`Model model`这两种类型数据可以给request域中放数据，用`request.getAttribute()`获取。\n\n## 35、请求处理-【源码分析】-自定义参数绑定原理\n\n```java\n@RestController\npublic class ParameterTestController {\n\n    /**\n     * 数据绑定：页面提交的请求数据（GET、POST）都可以和对象属性进行绑定\n     * @param person\n     * @return\n     */\n    @PostMapping(\"/saveuser\")\n    public Person saveuser(Person person){\n        return person;\n    }\n}\n```\n\n```java\n/**\n *     姓名： <input name=\"userName\"/> <br/>\n *     年龄： <input name=\"age\"/> <br/>\n *     生日： <input name=\"birth\"/> <br/>\n *     宠物姓名：<input name=\"pet.name\"/><br/>\n *     宠物年龄：<input name=\"pet.age\"/>\n */\n@Data\npublic class Person {\n    \n    private String userName;\n    private Integer age;\n    private Date birth;\n    private Pet pet;\n    \n}\n\n@Data\npublic class Pet {\n\n    private String name;\n    private String age;\n\n}\n```\n\n封装过程用到`ServletModelAttributeMethodProcessor`\n\n```java\npublic class ServletModelAttributeMethodProcessor extends ModelAttributeMethodProcessor {\n	\n    @Override//本方法在ModelAttributeMethodProcessor类，\n	public boolean supportsParameter(MethodParameter parameter) {\n		return (parameter.hasParameterAnnotation(ModelAttribute.class) ||\n				(this.annotationNotRequired && !BeanUtils.isSimpleProperty(parameter.getParameterType())));\n	}\n\n	@Override\n	@Nullable//本方法在ModelAttributeMethodProcessor类，\n	public final Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,\n			NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception {\n\n		...\n\n		String name = ModelFactory.getNameForParameter(parameter);\n		ModelAttribute ann = parameter.getParameterAnnotation(ModelAttribute.class);\n		if (ann != null) {\n			mavContainer.setBinding(name, ann.binding());\n		}\n\n		Object attribute = null;\n		BindingResult bindingResult = null;\n\n		if (mavContainer.containsAttribute(name)) {\n			attribute = mavContainer.getModel().get(name);\n		}\n		else {\n			// Create attribute instance\n			try {\n				attribute = createAttribute(name, parameter, binderFactory, webRequest);\n			}\n			catch (BindException ex) {\n				...\n			}\n		}\n\n		if (bindingResult == null) {\n			// Bean property binding and validation;\n			// skipped in case of binding failure on construction.\n			WebDataBinder binder = binderFactory.createBinder(webRequest, attribute, name);\n			if (binder.getTarget() != null) {\n				if (!mavContainer.isBindingDisabled(name)) {\n                    //web数据绑定器，将请求参数的值绑定到指定的JavaBean里面**\n					bindRequestParameters(binder, webRequest);\n				}\n				validateIfApplicable(binder, parameter);\n				if (binder.getBindingResult().hasErrors() && isBindExceptionRequired(binder, parameter)) {\n					throw new BindException(binder.getBindingResult());\n				}\n			}\n			// Value type adaptation, also covering java.util.Optional\n			if (!parameter.getParameterType().isInstance(attribute)) {\n				attribute = binder.convertIfNecessary(binder.getTarget(), parameter.getParameterType(), parameter);\n			}\n			bindingResult = binder.getBindingResult();\n		}\n\n		// Add resolved attribute and BindingResult at the end of the model\n		Map<String, Object> bindingResultModel = bindingResult.getModel();\n		mavContainer.removeAttributes(bindingResultModel);\n		mavContainer.addAllAttributes(bindingResultModel);\n\n		return attribute;\n	}\n}\n```\n\n**WebDataBinder 利用它里面的 Converters 将请求数据转成指定的数据类型。再次封装到JavaBean中**\n\n**在过程当中，用到GenericConversionService：在设置每一个值的时候，找它里面的所有converter那个可以将这个数据类型（request带来参数的字符串）转换到指定的类型**\n\n\n\n## 36、请求处理-【源码分析】-自定义Converter原理\n\n未来我们可以给WebDataBinder里面放自己的Converter；\n\n下面演示将字符串`“啊猫,3”`转换成`Pet`对象。\n\n```java\n    //1、WebMvcConfigurer定制化SpringMVC的功能\n    @Bean\n    public WebMvcConfigurer webMvcConfigurer(){\n        return new WebMvcConfigurer() {\n\n            @Override\n            public void addFormatters(FormatterRegistry registry) {\n                registry.addConverter(new Converter<String, Pet>() {\n\n                    @Override\n                    public Pet convert(String source) {\n                        // 啊猫,3\n                        if(!StringUtils.isEmpty(source)){\n                            Pet pet = new Pet();\n                            String[] split = source.split(\",\");\n                            pet.setName(split[0]);\n                            pet.setAge(Integer.parseInt(split[1]));\n                            return pet;\n                        }\n                        return null;\n                    }\n                });\n            }\n        };\n    }\n```\n\n\n\n## 37、响应处理-【源码分析】-ReturnValueHandler原理\n\n![在这里插入图片描述](image/20210205010403920.jpg)\n\n假设给前端自动返回json数据，需要引入相关的依赖\n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-web</artifactId>\n</dependency>\n\n<!-- web场景自动引入了json场景 -->\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-json</artifactId>\n    <version>2.3.4.RELEASE</version>\n    <scope>compile</scope>\n</dependency>\n```\n\n控制层代码如下：\n\n```java\n@Controller\npublic class ResponseTestController {\n    \n	@ResponseBody  //利用返回值处理器里面的消息转换器进行处理\n    @GetMapping(value = \"/test/person\")\n    public Person getPerson(){\n        Person person = new Person();\n        person.setAge(28);\n        person.setBirth(new Date());\n        person.setUserName(\"zhangsan\");\n        return person;\n    }\n\n}\n```\n\n[32、请求处理-【源码分析】-各种类型参数解析原理 - 返回值处理器](#)有讨论**ReturnValueHandler**。现在直接看看重点：\n\n```java\npublic class RequestMappingHandlerAdapter extends AbstractHandlerMethodAdapter\n		implements BeanFactoryAware, InitializingBean {\n\n    ...\n    \n	@Nullable\n	protected ModelAndView invokeHandlerMethod(HttpServletRequest request,\n			HttpServletResponse response, HandlerMethod handlerMethod) throws Exception {\n\n		ServletWebRequest webRequest = new ServletWebRequest(request, response);\n		try {\n			\n            ...\n            \n            ServletInvocableHandlerMethod invocableMethod = createInvocableHandlerMethod(handlerMethod);\n                \n			if (this.argumentResolvers != null) {\n				invocableMethod.setHandlerMethodArgumentResolvers(this.argumentResolvers);\n			}\n			if (this.returnValueHandlers != null) {//<----关注点\n				invocableMethod.setHandlerMethodReturnValueHandlers(this.returnValueHandlers);\n			}\n\n            ...\n\n			invocableMethod.invokeAndHandle(webRequest, mavContainer);//看下块代码\n			if (asyncManager.isConcurrentHandlingStarted()) {\n				return null;\n			}\n\n			return getModelAndView(mavContainer, modelFactory, webRequest);\n		}\n		finally {\n			webRequest.requestCompleted();\n		}\n	}\n```\n\n\n\n```java\npublic class ServletInvocableHandlerMethod extends InvocableHandlerMethod {\n    \n	public void invokeAndHandle(ServletWebRequest webRequest, ModelAndViewContainer mavContainer,\n			Object... providedArgs) throws Exception {\n\n		Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs);\n		\n        ...\n        \n		try {\n            //看下块代码\n			this.returnValueHandlers.handleReturnValue(\n					returnValue, getReturnValueType(returnValue), mavContainer, webRequest);\n		}\n		catch (Exception ex) {\n			...\n		}\n	}\n```\n\n\n\n```java\npublic class HandlerMethodReturnValueHandlerComposite implements HandlerMethodReturnValueHandler {\n    \n    ...\n    \n	@Override\n	public void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType,\n			ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception {\n\n        //selectHandler()实现在下面\n		HandlerMethodReturnValueHandler handler = selectHandler(returnValue, returnType);\n		if (handler == null) {\n			throw new IllegalArgumentException(\"Unknown return value type: \" + returnType.getParameterType().getName());\n		}\n        //开始处理\n		handler.handleReturnValue(returnValue, returnType, mavContainer, webRequest);\n	}\n    \n   	@Nullable\n	private HandlerMethodReturnValueHandler selectHandler(@Nullable Object value, MethodParameter returnType) {\n		boolean isAsyncValue = isAsyncReturnValue(value, returnType);\n		for (HandlerMethodReturnValueHandler handler : this.returnValueHandlers) {\n			if (isAsyncValue && !(handler instanceof AsyncHandlerMethodReturnValueHandler)) {\n				continue;\n			}\n			if (handler.supportsReturnType(returnType)) {\n				return handler;\n			}\n		}\n		return null;\n	}\n    \n```\n\n\n\n`@ResponseBody` 注解，即`RequestResponseBodyMethodProcessor`，它实现`HandlerMethodReturnValueHandler`接口\n\n```java\npublic class RequestResponseBodyMethodProcessor extends AbstractMessageConverterMethodProcessor {\n\n    ...\n    \n	@Override\n	public void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType,\n			ModelAndViewContainer mavContainer, NativeWebRequest webRequest)\n			throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n\n		mavContainer.setRequestHandled(true);\n		ServletServerHttpRequest inputMessage = createInputMessage(webRequest);\n		ServletServerHttpResponse outputMessage = createOutputMessage(webRequest);\n\n        // 使用消息转换器进行写出操作，本方法下一章节介绍：\n		// Try even with null return value. ResponseBodyAdvice could get involved.\n		writeWithMessageConverters(returnValue, returnType, inputMessage, outputMessage);\n	}\n\n}\n\n```\n\n\n\n## 38、响应处理-【源码分析】-HTTPMessageConverter原理\n\n返回值处理器`ReturnValueHandler`原理：\n\n1. 返回值处理器判断是否支持这种类型返回值 `supportsReturnType`\n2. 返回值处理器调用 `handleReturnValue` 进行处理\n3. `RequestResponseBodyMethodProcessor` 可以处理返回值标了`@ResponseBody` 注解的。\n   - 利用 `MessageConverters` 进行处理 将数据写为json\n     1. 内容协商（浏览器默认会以请求头的方式告诉服务器他能接受什么样的内容类型）\n     2. 服务器最终根据自己自身的能力，决定服务器能生产出什么样内容类型的数据，\n     3. SpringMVC会挨个遍历所有容器底层的 `HttpMessageConverter` ，看谁能处理？\n        1. 得到`MappingJackson2HttpMessageConverter`可以将对象写为json\n        2. 利用`MappingJackson2HttpMessageConverter`将对象转为json再写出去。\n\n\n\n```java\n//RequestResponseBodyMethodProcessor继承这类\npublic abstract class AbstractMessageConverterMethodProcessor extends AbstractMessageConverterMethodArgumentResolver\n		implements HandlerMethodReturnValueHandler {\n\n    ...\n    \n    //承接上一节内容\n    protected <T> void writeWithMessageConverters(@Nullable T value, MethodParameter returnType,\n                ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage)\n                throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n\n            Object body;\n            Class<?> valueType;\n            Type targetType;\n\n            if (value instanceof CharSequence) {\n                body = value.toString();\n                valueType = String.class;\n                targetType = String.class;\n            }\n            else {\n                body = value;\n                valueType = getReturnValueType(body, returnType);\n                targetType = GenericTypeResolver.resolveType(getGenericType(returnType), returnType.getContainingClass());\n            }\n\n			...\n\n            //内容协商（浏览器默认会以请求头(参数Accept)的方式告诉服务器他能接受什么样的内容类型）\n            MediaType selectedMediaType = null;\n            MediaType contentType = outputMessage.getHeaders().getContentType();\n            boolean isContentTypePreset = contentType != null && contentType.isConcrete();\n            if (isContentTypePreset) {\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"Found \'Content-Type:\" + contentType + \"\' in response\");\n                }\n                selectedMediaType = contentType;\n            }\n            else {\n                HttpServletRequest request = inputMessage.getServletRequest();\n                List<MediaType> acceptableTypes = getAcceptableMediaTypes(request);\n                //服务器最终根据自己自身的能力，决定服务器能生产出什么样内容类型的数据\n                List<MediaType> producibleTypes = getProducibleMediaTypes(request, valueType, targetType);\n\n                if (body != null && producibleTypes.isEmpty()) {\n                    throw new HttpMessageNotWritableException(\n                            \"No converter found for return value of type: \" + valueType);\n                }\n                List<MediaType> mediaTypesToUse = new ArrayList<>();\n                for (MediaType requestedType : acceptableTypes) {\n                    for (MediaType producibleType : producibleTypes) {\n                        if (requestedType.isCompatibleWith(producibleType)) {\n                            mediaTypesToUse.add(getMostSpecificMediaType(requestedType, producibleType));\n                        }\n                    }\n                }\n                if (mediaTypesToUse.isEmpty()) {\n                    if (body != null) {\n                        throw new HttpMediaTypeNotAcceptableException(producibleTypes);\n                    }\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"No match for \" + acceptableTypes + \", supported: \" + producibleTypes);\n                    }\n                    return;\n                }\n\n                MediaType.sortBySpecificityAndQuality(mediaTypesToUse);\n\n                //选择一个MediaType\n                for (MediaType mediaType : mediaTypesToUse) {\n                    if (mediaType.isConcrete()) {\n                        selectedMediaType = mediaType;\n                        break;\n                    }\n                    else if (mediaType.isPresentIn(ALL_APPLICATION_MEDIA_TYPES)) {\n                        selectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n                        break;\n                    }\n                }\n\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"Using \'\" + selectedMediaType + \"\', given \" +\n                            acceptableTypes + \" and supported \" + producibleTypes);\n                }\n            }\n\n        	\n            if (selectedMediaType != null) {\n                selectedMediaType = selectedMediaType.removeQualityValue();\n                //本节主角：HttpMessageConverter\n                for (HttpMessageConverter<?> converter : this.messageConverters) {\n                    GenericHttpMessageConverter genericConverter = (converter instanceof GenericHttpMessageConverter ?\n                            (GenericHttpMessageConverter<?>) converter : null);\n                    \n                    //判断是否可写\n                    if (genericConverter != null ?\n                            ((GenericHttpMessageConverter) converter).canWrite(targetType, valueType, selectedMediaType) :\n                            converter.canWrite(valueType, selectedMediaType)) {\n                        body = getAdvice().beforeBodyWrite(body, returnType, selectedMediaType,\n                                (Class<? extends HttpMessageConverter<?>>) converter.getClass(),\n                                inputMessage, outputMessage);\n                        if (body != null) {\n                            Object theBody = body;\n                            LogFormatUtils.traceDebug(logger, traceOn ->\n                                    \"Writing [\" + LogFormatUtils.formatValue(theBody, !traceOn) + \"]\");\n                            addContentDispositionHeader(inputMessage, outputMessage);\n							//开始写入\n                            if (genericConverter != null) {\n                                genericConverter.write(body, targetType, selectedMediaType, outputMessage);\n                            }\n                            else {\n                                ((HttpMessageConverter) converter).write(body, selectedMediaType, outputMessage);\n                            }\n                        }\n                        else {\n                            if (logger.isDebugEnabled()) {\n                                logger.debug(\"Nothing to write: null body\");\n                            }\n                        }\n                        return;\n                    }\n                }\n            }\n			...\n        }\n```\n\n`HTTPMessageConverter`接口：\n\n```java\n/**\n * Strategy interface for converting from and to HTTP requests and responses.\n */\npublic interface HttpMessageConverter<T> {\n\n	/**\n	 * Indicates whether the given class can be read by this converter.\n	 */\n	boolean canRead(Class<?> clazz, @Nullable MediaType mediaType);\n\n	/**\n	 * Indicates whether the given class can be written by this converter.\n	 */\n	boolean canWrite(Class<?> clazz, @Nullable MediaType mediaType);\n\n	/**\n	 * Return the list of {@link MediaType} objects supported by this converter.\n	 */\n	List<MediaType> getSupportedMediaTypes();\n\n	/**\n	 * Read an object of the given type from the given input message, and returns it.\n	 */\n	T read(Class<? extends T> clazz, HttpInputMessage inputMessage)\n			throws IOException, HttpMessageNotReadableException;\n\n	/**\n	 * Write an given object to the given output message.\n	 */\n	void write(T t, @Nullable MediaType contentType, HttpOutputMessage outputMessage)\n			throws IOException, HttpMessageNotWritableException;\n\n}\n\n```\n\n`HttpMessageConverter`: 看是否支持将 此 `Class`类型的对象，转为`MediaType`类型的数据。\n\n例子：`Person`对象转为JSON，或者 JSON转为`Person`，这将用到`MappingJackson2HttpMessageConverter`\n\n![在这里插入图片描述](image/20210205010509984.png)\n\n```java\npublic class MappingJackson2HttpMessageConverter extends AbstractJackson2HttpMessageConverter {\n	...\n}\n```\n\n关于`MappingJackson2HttpMessageConverter`的实例化请看下节。\n\n### 关于HttpMessageConverters的初始化\n\n`DispatcherServlet`的初始化时会调用`initHandlerAdapters(ApplicationContext context)`\n\n```java\npublic class DispatcherServlet extends FrameworkServlet {\n    \n    ...\n    \n	private void initHandlerAdapters(ApplicationContext context) {\n		this.handlerAdapters = null;\n\n		if (this.detectAllHandlerAdapters) {\n			// Find all HandlerAdapters in the ApplicationContext, including ancestor contexts.\n			Map<String, HandlerAdapter> matchingBeans =\n					BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerAdapter.class, true, false);\n			if (!matchingBeans.isEmpty()) {\n				this.handlerAdapters = new ArrayList<>(matchingBeans.values());\n				// We keep HandlerAdapters in sorted order.\n				AnnotationAwareOrderComparator.sort(this.handlerAdapters);\n			}\n		}\n      ...\n```\n\n上述代码会加载`ApplicationContext`的所有`HandlerAdapter`，用来处理`@RequestMapping`的`RequestMappingHandlerAdapter`实现`HandlerAdapter`接口，`RequestMappingHandlerAdapter`也被实例化。\n\n```java\npublic class RequestMappingHandlerAdapter extends AbstractHandlerMethodAdapter\n		implements BeanFactoryAware, InitializingBean {\n    \n    ...\n\n    private List<HttpMessageConverter<?>> messageConverters;\n    \n    ...\n    \n	public RequestMappingHandlerAdapter() {\n		this.messageConverters = new ArrayList<>(4);\n		this.messageConverters.add(new ByteArrayHttpMessageConverter());\n		this.messageConverters.add(new StringHttpMessageConverter());\n		if (!shouldIgnoreXml) {\n			try {\n				this.messageConverters.add(new SourceHttpMessageConverter<>());\n			}\n			catch (Error err) {\n				// Ignore when no TransformerFactory implementation is available\n			}\n		}\n		this.messageConverters.add(new AllEncompassingFormHttpMessageConverter());\n	}\n```\n\n在构造器中看到**一堆**`HttpMessageConverter`。接着，重点查看`AllEncompassingFormHttpMessageConverter`类：\n\n```java\npublic class AllEncompassingFormHttpMessageConverter extends FormHttpMessageConverter {\n\n	/**\n	 * Boolean flag controlled by a {@code spring.xml.ignore} system property that instructs Spring to\n	 * ignore XML, i.e. to not initialize the XML-related infrastructure.\n	 * <p>The default is \"false\".\n	 */\n	private static final boolean shouldIgnoreXml = SpringProperties.getFlag(\"spring.xml.ignore\");\n\n	private static final boolean jaxb2Present;\n\n	private static final boolean jackson2Present;\n\n	private static final boolean jackson2XmlPresent;\n\n	private static final boolean jackson2SmilePresent;\n\n	private static final boolean gsonPresent;\n\n	private static final boolean jsonbPresent;\n\n	private static final boolean kotlinSerializationJsonPresent;\n\n	static {\n		ClassLoader classLoader = AllEncompassingFormHttpMessageConverter.class.getClassLoader();\n		jaxb2Present = ClassUtils.isPresent(\"javax.xml.bind.Binder\", classLoader);\n		jackson2Present = ClassUtils.isPresent(\"com.fasterxml.jackson.databind.ObjectMapper\", classLoader) &&\n						ClassUtils.isPresent(\"com.fasterxml.jackson.core.JsonGenerator\", classLoader);\n		jackson2XmlPresent = ClassUtils.isPresent(\"com.fasterxml.jackson.dataformat.xml.XmlMapper\", classLoader);\n		jackson2SmilePresent = ClassUtils.isPresent(\"com.fasterxml.jackson.dataformat.smile.SmileFactory\", classLoader);\n		gsonPresent = ClassUtils.isPresent(\"com.google.gson.Gson\", classLoader);\n		jsonbPresent = ClassUtils.isPresent(\"javax.json.bind.Jsonb\", classLoader);\n		kotlinSerializationJsonPresent = ClassUtils.isPresent(\"kotlinx.serialization.json.Json\", classLoader);\n	}\n\n\n	public AllEncompassingFormHttpMessageConverter() {\n		if (!shouldIgnoreXml) {\n			try {\n				addPartConverter(new SourceHttpMessageConverter<>());\n			}\n			catch (Error err) {\n				// Ignore when no TransformerFactory implementation is available\n			}\n\n			if (jaxb2Present && !jackson2XmlPresent) {\n				addPartConverter(new Jaxb2RootElementHttpMessageConverter());\n			}\n		}\n\n		if (jackson2Present) {\n			addPartConverter(new MappingJackson2HttpMessageConverter());//<----重点看这里\n		}\n		else if (gsonPresent) {\n			addPartConverter(new GsonHttpMessageConverter());\n		}\n		else if (jsonbPresent) {\n			addPartConverter(new JsonbHttpMessageConverter());\n		}\n		else if (kotlinSerializationJsonPresent) {\n			addPartConverter(new KotlinSerializationJsonHttpMessageConverter());\n		}\n\n		if (jackson2XmlPresent && !shouldIgnoreXml) {\n			addPartConverter(new MappingJackson2XmlHttpMessageConverter());\n		}\n\n		if (jackson2SmilePresent) {\n			addPartConverter(new MappingJackson2SmileHttpMessageConverter());\n		}\n	}\n\n}\n\npublic class FormHttpMessageConverter implements HttpMessageConverter<MultiValueMap<String, ?>> {\n    \n    ...\n        \n    private List<HttpMessageConverter<?>> partConverters = new ArrayList<>();\n    \n    ...\n        \n    public void addPartConverter(HttpMessageConverter<?> partConverter) {\n		Assert.notNull(partConverter, \"\'partConverter\' must not be null\");\n		this.partConverters.add(partConverter);\n	}\n    \n    ...\n}\n\n```\n\n在`AllEncompassingFormHttpMessageConverter`类构造器看到`MappingJackson2HttpMessageConverter`类的实例化，`AllEncompassingFormHttpMessageConverter`**包含**`MappingJackson2HttpMessageConverter`。\n\n `ReturnValueHandler`是怎么与`MappingJackson2HttpMessageConverter`关联起来？请看下节。\n\n### ReturnValueHandler与MappingJackson2HttpMessageConverter关联\n\n再次回顾`RequestMappingHandlerAdapter`\n\n```java\npublic class RequestMappingHandlerAdapter extends AbstractHandlerMethodAdapter\n		implements BeanFactoryAware, InitializingBean {\n    \n    ...\n    @Nullable\n	private HandlerMethodReturnValueHandlerComposite returnValueHandlers;//我们关注的returnValueHandlers\n    \n   	\n    @Override\n	@Nullable//本方法在AbstractHandlerMethodAdapter\n	public final ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler)\n			throws Exception {\n\n		return handleInternal(request, response, (HandlerMethod) handler);\n	}\n        \n    @Override\n	protected ModelAndView handleInternal(HttpServletRequest request,\n			HttpServletResponse response, HandlerMethod handlerMethod) throws Exception {\n		ModelAndView mav;\n        ...\n        mav = invokeHandlerMethod(request, response, handlerMethod);\n        ...\n		return mav;\n	}\n    \n    @Nullable\n	protected ModelAndView invokeHandlerMethod(HttpServletRequest request,\n			HttpServletResponse response, HandlerMethod handlerMethod) throws Exception {\n\n		ServletWebRequest webRequest = new ServletWebRequest(request, response);\n		try {\n			WebDataBinderFactory binderFactory = getDataBinderFactory(handlerMethod);\n			ModelFactory modelFactory = getModelFactory(handlerMethod, binderFactory);\n\n			ServletInvocableHandlerMethod invocableMethod = createInvocableHandlerMethod(handlerMethod);\n			if (this.argumentResolvers != null) {\n				invocableMethod.setHandlerMethodArgumentResolvers(this.argumentResolvers);\n			}\n			if (this.returnValueHandlers != null) {//<---我们关注的returnValueHandlers\n				invocableMethod.setHandlerMethodReturnValueHandlers(this.returnValueHandlers);\n			}\n            \n            ...\n            \n			invocableMethod.invokeAndHandle(webRequest, mavContainer);\n			if (asyncManager.isConcurrentHandlingStarted()) {\n				return null;\n			}\n\n			return getModelAndView(mavContainer, modelFactory, webRequest);\n		}\n		finally {\n			webRequest.requestCompleted();\n		}\n	}\n    \n   @Override\n	public void afterPropertiesSet() {\n		// Do this first, it may add ResponseBody advice beans\n		\n        ...\n        \n		if (this.returnValueHandlers == null) {//赋值returnValueHandlers\n			List<HandlerMethodReturnValueHandler> handlers = getDefaultReturnValueHandlers();\n			this.returnValueHandlers = new HandlerMethodReturnValueHandlerComposite().addHandlers(handlers);\n		}\n	}\n    \n    private List<HandlerMethodReturnValueHandler> getDefaultReturnValueHandlers() {\n		List<HandlerMethodReturnValueHandler> handlers = new ArrayList<>(20);\n\n		...\n		// Annotation-based return value types\n        //这里就是 ReturnValueHandler与 MappingJackson2HttpMessageConverter关联 的关键点\n		handlers.add(new RequestResponseBodyMethodProcessor(getMessageConverters(),//<---MessageConverters也就传参传进来的\n				this.contentNegotiationManager, this.requestResponseBodyAdvice));//\n        ...\n\n		return handlers;\n	}\n    \n    //------\n    \n    public List<HttpMessageConverter<?>> getMessageConverters() {\n		return this.messageConverters;\n	}\n    \n    //RequestMappingHandlerAdapter构造器已初始化部分messageConverters\n   	public RequestMappingHandlerAdapter() {\n		this.messageConverters = new ArrayList<>(4);\n		this.messageConverters.add(new ByteArrayHttpMessageConverter());\n		this.messageConverters.add(new StringHttpMessageConverter());\n		if (!shouldIgnoreXml) {\n			try {\n				this.messageConverters.add(new SourceHttpMessageConverter<>());\n			}\n			catch (Error err) {\n				// Ignore when no TransformerFactory implementation is available\n			}\n		}\n		this.messageConverters.add(new AllEncompassingFormHttpMessageConverter());\n	}\n\n    ...\n              \n}\n```\n\n应用中`WebMvcAutoConfiguration`（底层是`WebMvcConfigurationSupport`实现）传入更多`messageConverters`，其中就包含`MappingJackson2HttpMessageConverter`。\n\n## 39、响应处理-【源码分析】-内容协商原理\n\n根据客户端接收能力不同，返回不同媒体类型的数据。\n\n引入XML依赖：\n\n```xml\n <dependency>\n     <groupId>com.fasterxml.jackson.dataformat</groupId>\n     <artifactId>jackson-dataformat-xml</artifactId>\n</dependency>\n```\n\n可用Postman软件分别测试返回json和xml：只需要改变请求头中Accept字段（application/json、application/xml）。\n\nHttp协议中规定的，Accept字段告诉服务器本客户端可以接收的数据类型。\n\n**内容协商原理**：\n\n1. 判断当前响应头中是否已经有确定的媒体类型`MediaType`。\n2. 获取客户端（PostMan、浏览器）支持接收的内容类型。（获取客户端Accept请求头字段application/xml）（这一步在下一节有详细介绍）\n   - `contentNegotiationManager` 内容协商管理器 默认使用基于请求头的策略\n   - `HeaderContentNegotiationStrategy`  确定客户端可以接收的内容类型 \n3. 遍历循环所有当前系统的 `MessageConverter`，看谁支持操作这个对象（Person）\n4. 找到支持操作Person的converter，把converter支持的媒体类型统计出来。\n5. 客户端需要application/xml，服务端有10种MediaType。\n6. 进行内容协商的最佳匹配媒体类型\n7. 用 支持 将对象转为 最佳匹配媒体类型 的converter。调用它进行转化 。\n\n\n\n```java\n//RequestResponseBodyMethodProcessor继承这类\npublic abstract class AbstractMessageConverterMethodProcessor extends AbstractMessageConverterMethodArgumentResolver\n		implements HandlerMethodReturnValueHandler {\n\n    ...\n    \n    //跟上一节的代码一致\n    protected <T> void writeWithMessageConverters(@Nullable T value, MethodParameter returnType,\n                ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage)\n                throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n\n            Object body;\n            Class<?> valueType;\n            Type targetType;\n\n            if (value instanceof CharSequence) {\n                body = value.toString();\n                valueType = String.class;\n                targetType = String.class;\n            }\n            else {\n                body = value;\n                valueType = getReturnValueType(body, returnType);\n                targetType = GenericTypeResolver.resolveType(getGenericType(returnType), returnType.getContainingClass());\n            }\n\n			...\n\n            //本节重点\n            //内容协商（浏览器默认会以请求头(参数Accept)的方式告诉服务器他能接受什么样的内容类型）\n            MediaType selectedMediaType = null;\n            MediaType contentType = outputMessage.getHeaders().getContentType();\n            boolean isContentTypePreset = contentType != null && contentType.isConcrete();\n            if (isContentTypePreset) {\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"Found \'Content-Type:\" + contentType + \"\' in response\");\n                }\n                selectedMediaType = contentType;\n            }\n            else {\n                HttpServletRequest request = inputMessage.getServletRequest();\n                List<MediaType> acceptableTypes = getAcceptableMediaTypes(request);\n                //服务器最终根据自己自身的能力，决定服务器能生产出什么样内容类型的数据\n                List<MediaType> producibleTypes = getProducibleMediaTypes(request, valueType, targetType);\n\n                if (body != null && producibleTypes.isEmpty()) {\n                    throw new HttpMessageNotWritableException(\n                            \"No converter found for return value of type: \" + valueType);\n                }\n                List<MediaType> mediaTypesToUse = new ArrayList<>();\n                for (MediaType requestedType : acceptableTypes) {\n                    for (MediaType producibleType : producibleTypes) {\n                        if (requestedType.isCompatibleWith(producibleType)) {\n                            mediaTypesToUse.add(getMostSpecificMediaType(requestedType, producibleType));\n                        }\n                    }\n                }\n                if (mediaTypesToUse.isEmpty()) {\n                    if (body != null) {\n                        throw new HttpMediaTypeNotAcceptableException(producibleTypes);\n                    }\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"No match for \" + acceptableTypes + \", supported: \" + producibleTypes);\n                    }\n                    return;\n                }\n\n                MediaType.sortBySpecificityAndQuality(mediaTypesToUse);\n\n                //选择一个MediaType\n                for (MediaType mediaType : mediaTypesToUse) {\n                    if (mediaType.isConcrete()) {\n                        selectedMediaType = mediaType;\n                        break;\n                    }\n                    else if (mediaType.isPresentIn(ALL_APPLICATION_MEDIA_TYPES)) {\n                        selectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n                        break;\n                    }\n                }\n\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"Using \'\" + selectedMediaType + \"\', given \" +\n                            acceptableTypes + \" and supported \" + producibleTypes);\n                }\n            }\n\n        	\n            if (selectedMediaType != null) {\n                selectedMediaType = selectedMediaType.removeQualityValue();\n                //本节主角：HttpMessageConverter\n                for (HttpMessageConverter<?> converter : this.messageConverters) {\n                    GenericHttpMessageConverter genericConverter = (converter instanceof GenericHttpMessageConverter ?\n                            (GenericHttpMessageConverter<?>) converter : null);\n                    \n                    //判断是否可写\n                    if (genericConverter != null ?\n                            ((GenericHttpMessageConverter) converter).canWrite(targetType, valueType, selectedMediaType) :\n                            converter.canWrite(valueType, selectedMediaType)) {\n                        body = getAdvice().beforeBodyWrite(body, returnType, selectedMediaType,\n                                (Class<? extends HttpMessageConverter<?>>) converter.getClass(),\n                                inputMessage, outputMessage);\n                        if (body != null) {\n                            Object theBody = body;\n                            LogFormatUtils.traceDebug(logger, traceOn ->\n                                    \"Writing [\" + LogFormatUtils.formatValue(theBody, !traceOn) + \"]\");\n                            addContentDispositionHeader(inputMessage, outputMessage);\n							//开始写入\n                            if (genericConverter != null) {\n                                genericConverter.write(body, targetType, selectedMediaType, outputMessage);\n                            }\n                            else {\n                                ((HttpMessageConverter) converter).write(body, selectedMediaType, outputMessage);\n                            }\n                        }\n                        else {\n                            if (logger.isDebugEnabled()) {\n                                logger.debug(\"Nothing to write: null body\");\n                            }\n                        }\n                        return;\n                    }\n                }\n            }\n			...\n        }\n```\n\n\n\n## 40、响应处理-【源码分析】-基于请求参数的内容协商原理\n\n上一节内容协商原理的第二步：\n\n获取客户端（PostMan、浏览器）支持接收的内容类型。（获取客户端Accept请求头字段application/xml）\n\n- `contentNegotiationManager` 内容协商管理器 默认使用基于请求头的策略\n- `HeaderContentNegotiationStrategy`  确定客户端可以接收的内容类型 \n\n```java\n//RequestResponseBodyMethodProcessor继承这类\npublic abstract class AbstractMessageConverterMethodProcessor extends AbstractMessageConverterMethodArgumentResolver\n		implements HandlerMethodReturnValueHandler {\n\n    ...\n    \n    //跟上一节的代码一致\n    protected <T> void writeWithMessageConverters(@Nullable T value, MethodParameter returnType,\n                ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage)\n                throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n\n            Object body;\n            Class<?> valueType;\n            Type targetType;\n        \n        	...\n        \n                    //本节重点\n            //内容协商（浏览器默认会以请求头(参数Accept)的方式告诉服务器他能接受什么样的内容类型）\n            MediaType selectedMediaType = null;\n            MediaType contentType = outputMessage.getHeaders().getContentType();\n            boolean isContentTypePreset = contentType != null && contentType.isConcrete();\n            if (isContentTypePreset) {\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"Found \'Content-Type:\" + contentType + \"\' in response\");\n                }\n                selectedMediaType = contentType;\n            }\n            else {\n                HttpServletRequest request = inputMessage.getServletRequest();\n                List<MediaType> acceptableTypes = getAcceptableMediaTypes(request);\n                //服务器最终根据自己自身的能力，决定服务器能生产出什么样内容类型的数据\n                List<MediaType> producibleTypes = getProducibleMediaTypes(request, valueType, targetType);\n            ...\n            \n	}\n    \n    //在AbstractMessageConverterMethodArgumentResolver类内\n   	private List<MediaType> getAcceptableMediaTypes(HttpServletRequest request)\n			throws HttpMediaTypeNotAcceptableException {\n\n        //内容协商管理器 默认使用基于请求头的策略\n		return this.contentNegotiationManager.resolveMediaTypes(new ServletWebRequest(request));\n	}\n        \n}\n```\n\n\n\n```java\npublic class ContentNegotiationManager implements ContentNegotiationStrategy, MediaTypeFileExtensionResolver {\n	\n    ...\n    \n    public ContentNegotiationManager() {\n		this(new HeaderContentNegotiationStrategy());//内容协商管理器 默认使用基于请求头的策略\n	}\n    \n    @Override\n	public List<MediaType> resolveMediaTypes(NativeWebRequest request) throws HttpMediaTypeNotAcceptableException {\n		for (ContentNegotiationStrategy strategy : this.strategies) {\n			List<MediaType> mediaTypes = strategy.resolveMediaTypes(request);\n			if (mediaTypes.equals(MEDIA_TYPE_ALL_LIST)) {\n				continue;\n			}\n			return mediaTypes;\n		}\n		return MEDIA_TYPE_ALL_LIST;\n	}\n    ...\n    \n}\n```\n\n\n\n```java\n//基于请求头的策略\npublic class HeaderContentNegotiationStrategy implements ContentNegotiationStrategy {\n\n	/**\n	 * {@inheritDoc}\n	 * @throws HttpMediaTypeNotAcceptableException if the \'Accept\' header cannot be parsed\n	 */\n	@Override\n	public List<MediaType> resolveMediaTypes(NativeWebRequest request)\n			throws HttpMediaTypeNotAcceptableException {\n\n		String[] headerValueArray = request.getHeaderValues(HttpHeaders.ACCEPT);\n		if (headerValueArray == null) {\n			return MEDIA_TYPE_ALL_LIST;\n		}\n\n		List<String> headerValues = Arrays.asList(headerValueArray);\n		try {\n			List<MediaType> mediaTypes = MediaType.parseMediaTypes(headerValues);\n			MediaType.sortBySpecificityAndQuality(mediaTypes);\n			return !CollectionUtils.isEmpty(mediaTypes) ? mediaTypes : MEDIA_TYPE_ALL_LIST;\n		}\n		catch (InvalidMediaTypeException ex) {\n			throw new HttpMediaTypeNotAcceptableException(\n					\"Could not parse \'Accept\' header \" + headerValues + \": \" + ex.getMessage());\n		}\n	}\n\n}\n```\n\n\n\n### 开启浏览器参数方式内容协商功能\n\n为了方便内容协商，开启基于请求参数的内容协商功能。\n\n```yaml\nspring:\n  mvc:\n    contentnegotiation:\n      favor-parameter: true  #开启请求参数内容协商模式\n```\n\n内容协商管理器，就会多了一个`ParameterContentNegotiationStrategy`（由Spring容器注入）\n\n```java\npublic class ParameterContentNegotiationStrategy extends AbstractMappingContentNegotiationStrategy {\n\n	private String parameterName = \"format\";//\n\n\n	/**\n	 * Create an instance with the given map of file extensions and media types.\n	 */\n	public ParameterContentNegotiationStrategy(Map<String, MediaType> mediaTypes) {\n		super(mediaTypes);\n	}\n\n\n	/**\n	 * Set the name of the parameter to use to determine requested media types.\n	 * <p>By default this is set to {@code \"format\"}.\n	 */\n	public void setParameterName(String parameterName) {\n		Assert.notNull(parameterName, \"\'parameterName\' is required\");\n		this.parameterName = parameterName;\n	}\n\n	public String getParameterName() {\n		return this.parameterName;\n	}\n\n\n	@Override\n	@Nullable\n	protected String getMediaTypeKey(NativeWebRequest request) {\n		return request.getParameter(getParameterName());\n	}\n    \n    //---以下方法在AbstractMappingContentNegotiationStrategy类\n    \n    @Override\n	public List<MediaType> resolveMediaTypes(NativeWebRequest webRequest)\n			throws HttpMediaTypeNotAcceptableException {\n\n		return resolveMediaTypeKey(webRequest, getMediaTypeKey(webRequest));\n	}\n\n	/**\n	 * An alternative to {@link #resolveMediaTypes(NativeWebRequest)} that accepts\n	 * an already extracted key.\n	 * @since 3.2.16\n	 */\n	public List<MediaType> resolveMediaTypeKey(NativeWebRequest webRequest, @Nullable String key)\n			throws HttpMediaTypeNotAcceptableException {\n\n		if (StringUtils.hasText(key)) {\n			MediaType mediaType = lookupMediaType(key);\n			if (mediaType != null) {\n				handleMatch(key, mediaType);\n				return Collections.singletonList(mediaType);\n			}\n			mediaType = handleNoMatch(webRequest, key);\n			if (mediaType != null) {\n				addMapping(key, mediaType);\n				return Collections.singletonList(mediaType);\n			}\n		}\n		return MEDIA_TYPE_ALL_LIST;\n	}\n    \n\n}\n```\n\n然后，浏览器地址输入带format参数的URL：\n\n```\nhttp://localhost:8080/test/person?format=json\n或\nhttp://localhost:8080/test/person?format=xml\n```\n\n这样，后端会根据参数format的值，返回对应json或xml格式的数据。\n\n\n\n## 41、响应处理-【源码分析】-自定义MessageConverter\n\n\n\n**实现多协议数据兼容。json、xml、x-guigu**（这个是自创的）\n\n1. `@ResponseBody` 响应数据出去 调用 `RequestResponseBodyMethodProcessor` 处理\n\n2. Processor 处理方法返回值。通过 `MessageConverter`处理\n\n3. 所有 `MessageConverter` 合起来可以支持各种媒体类型数据的操作（读、写）\n\n4. 内容协商找到最终的 `messageConverter`\n\nSpringMVC的什么功能，一个入口给容器中添加一个  `WebMvcConfigurer`\n\n\n\n```java\n@Configuration(proxyBeanMethods = false)\npublic class WebConfig {\n    @Bean\n    public WebMvcConfigurer webMvcConfigurer(){\n        return new WebMvcConfigurer() {\n\n            @Override\n            public void extendMessageConverters(List<HttpMessageConverter<?>> converters) {\n                converters.add(new GuiguMessageConverter());\n            }\n        }\n    }\n}\n```\n\n\n\n```java\n/**\n * 自定义的Converter\n */\npublic class GuiguMessageConverter implements HttpMessageConverter<Person> {\n\n    @Override\n    public boolean canRead(Class<?> clazz, MediaType mediaType) {\n        return false;\n    }\n\n    @Override\n    public boolean canWrite(Class<?> clazz, MediaType mediaType) {\n        return clazz.isAssignableFrom(Person.class);\n    }\n\n    /**\n     * 服务器要统计所有MessageConverter都能写出哪些内容类型\n     *\n     * application/x-guigu\n     * @return\n     */\n    @Override\n    public List<MediaType> getSupportedMediaTypes() {\n        return MediaType.parseMediaTypes(\"application/x-guigu\");\n    }\n\n    @Override\n    public Person read(Class<? extends Person> clazz, HttpInputMessage inputMessage) throws IOException, HttpMessageNotReadableException {\n        return null;\n    }\n\n    @Override\n    public void write(Person person, MediaType contentType, HttpOutputMessage outputMessage) throws IOException, HttpMessageNotWritableException {\n        //自定义协议数据的写出\n        String data = person.getUserName()+\";\"+person.getAge()+\";\"+person.getBirth();\n\n\n        //写出去\n        OutputStream body = outputMessage.getBody();\n        body.write(data.getBytes());\n    }\n}\n```\n\n\n\n```java\nimport java.util.Date;\n\n@Controller\npublic class ResponseTestController {\n\n    /**\n     * 1、浏览器发请求直接返回 xml    [application/xml]        jacksonXmlConverter\n     * 2、如果是ajax请求 返回 json   [application/json]      jacksonJsonConverter\n     * 3、如果硅谷app发请求，返回自定义协议数据  [appliaction/x-guigu]   xxxxConverter\n     *          属性值1;属性值2;\n     *\n     * 步骤：\n     * 1、添加自定义的MessageConverter进系统底层\n     * 2、系统底层就会统计出所有MessageConverter能操作哪些类型\n     * 3、客户端内容协商 [guigu--->guigu]\n     *\n     * 作业：如何以参数的方式进行内容协商\n     * @return\n     */\n    @ResponseBody  //利用返回值处理器里面的消息转换器进行处理\n    @GetMapping(value = \"/test/person\")\n    public Person getPerson(){\n        Person person = new Person();\n        person.setAge(28);\n        person.setBirth(new Date());\n        person.setUserName(\"zhangsan\");\n        return person;\n    }\n\n}\n```\n\n\n\n用Postman发送`/test/person`（请求头`Accept:application/x-guigu`)，将返回自定义协议数据的写出。\n\n## 42、响应处理-【源码分析】-浏览器与PostMan内容协商完全适配\n\n假设你想基于自定义请求参数的自定义内容协商功能。\n\n换句话，在地址栏输入`http://localhost:8080/test/person?format=gg`返回数据，跟`http://localhost:8080/test/person`且请求头参数`Accept:application/x-guigu`的返回自定义协议数据的一致。\n\n```java\n@Configuration(proxyBeanMethods = false)\npublic class WebConfig /*implements WebMvcConfigurer*/ {\n\n    //1、WebMvcConfigurer定制化SpringMVC的功能\n    @Bean\n    public WebMvcConfigurer webMvcConfigurer(){\n        return new WebMvcConfigurer() {\n\n            /**\n             * 自定义内容协商策略\n             * @param configurer\n             */\n            @Override\n            public void configureContentNegotiation(ContentNegotiationConfigurer configurer) {\n                //Map<String, MediaType> mediaTypes\n                Map<String, MediaType> mediaTypes = new HashMap<>();\n                mediaTypes.put(\"json\",MediaType.APPLICATION_JSON);\n                mediaTypes.put(\"xml\",MediaType.APPLICATION_XML);\n                //自定义媒体类型\n                mediaTypes.put(\"gg\",MediaType.parseMediaType(\"application/x-guigu\"));\n                //指定支持解析哪些参数对应的哪些媒体类型\n                ParameterContentNegotiationStrategy parameterStrategy = new ParameterContentNegotiationStrategy(mediaTypes);\n//                parameterStrategy.setParameterName(\"ff\");\n\n                //还需添加请求头处理策略，否则accept:application/json、application/xml则会失效\n                HeaderContentNegotiationStrategy headeStrategy = new HeaderContentNegotiationStrategy();\n\n                configurer.strategies(Arrays.asList(parameterStrategy, headeStrategy));\n            }\n        }\n    }\n    \n    ...\n    \n}\n```\n\n日后开发要注意，**有可能我们添加的自定义的功能会覆盖默认很多功能，导致一些默认的功能失效。**\n\n\n\n## 43、视图解析-Thymeleaf初体验\n\n> **Thymeleaf** is a modern server-side Java template engine for both web and standalone environments.\n>\n> Thymeleaf\'s main goal is to bring elegant *natural templates* to your development workflow — HTML that can be correctly displayed in browsers and also work as static prototypes, allowing for stronger collaboration in development teams.\n>\n> With modules for Spring Framework, a host of integrations with your favourite tools, and the ability to plug in your own functionality, Thymeleaf is ideal for modern-day HTML5 JVM web development — although there is much more it can do.——[Link](https://www.thymeleaf.org/)\n\n[Thymeleaf官方文档](https://www.thymeleaf.org/documentation.html)\n\n### thymeleaf使用\n\n#### 引入Starter\n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-thymeleaf</artifactId>\n</dependency>\n```\n\n#### 自动配置好了thymeleaf\n\n```java\n@Configuration(proxyBeanMethods = false)\n@EnableConfigurationProperties(ThymeleafProperties.class)\n@ConditionalOnClass({ TemplateMode.class, SpringTemplateEngine.class })\n@AutoConfigureAfter({ WebMvcAutoConfiguration.class, WebFluxAutoConfiguration.class })\npublic class ThymeleafAutoConfiguration {\n    ...\n}\n```\n\n自动配好的策略\n\n1. 所有thymeleaf的配置值都在 ThymeleafProperties\n\n2. 配置好了 **SpringTemplateEngine** \n\n3. 配好了 **ThymeleafViewResolver** \n\n4. 我们只需要直接开发页面\n\n```java\npublic static final String DEFAULT_PREFIX = \"classpath:/templates/\";//模板放置处\npublic static final String DEFAULT_SUFFIX = \".html\";//文件的后缀名\n```\n\n编写一个控制层：\n\n```java\n@Controller\npublic class ViewTestController {\n    @GetMapping(\"/hello\")\n    public String hello(Model model){\n        //model中的数据会被放在请求域中 request.setAttribute(\"a\",aa)\n        model.addAttribute(\"msg\",\"一定要大力发展工业文化\");\n        model.addAttribute(\"link\",\"http://www.baidu.com\");\n        return \"success\";\n    }\n}\n```\n\n`/templates/success.html`：\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n</head>\n<body>\n<h1 th:text=\"${msg}\">nice</h1>\n<h2>\n    <a href=\"www.baidu.com\" th:href=\"${link}\">去百度</a>  <br/>\n    <a href=\"www.google.com\" th:href=\"@{/link}\">去百度</a>\n</h2>\n</body>\n</html>\n```\n\n---\n\n```yaml\nserver:\n  servlet:\n    context-path: /app #设置应用名\n```\n\n这个设置后，URL要插入`/app`,  如`http://localhost:8080/app/hello.html`。\n\n### 基本语法\n\n#### 表达式\n\n| 表达式名字 | 语法   |                用途                |\n| ---------- | ------ | :--------------------------------: |\n| 变量取值   | ${...} |  获取请求域、session域、对象等值   |\n| 选择变量   | *{...} |          获取上下文对象值          |\n| 消息       | #{...} |           获取国际化等值           |\n| 链接       | @{...} |              生成链接              |\n| 片段表达式 | ~{...} | jsp:include 作用，引入公共页面片段 |\n\n#### 字面量\n\n- 文本值: **\'one text\'** **,** **\'Another one!\'** **,…**\n- 数字: **0** **,** **34** **,** **3.0** **,** **12.3** **,…**\n- 布尔值: **true** **,** **false**\n- 空值: **null**\n- 变量： one，two，.... 变量不能有空格\n\n#### 文本操作\n\n- 字符串拼接: **+**\n- 变量替换: **|The name is ${name}|** \n\n#### 数学运算\n\n- 运算符: + , - , * , / , %\n\n#### 布尔运算\n\n- 运算符:  **and** **,** **or**\n- 一元运算: **!** **,** **not** \n\n#### 比较运算\n\n- 比较: **>** **,** **<** **,** **>=** **,** **<=** **(** **gt** **,** **lt** **,** **ge** **,** **le** **)**\n- 等式: **==** **,** **!=** **(** **eq** **,** **ne** **)** \n\n#### 条件运算\n\n- If-then: **(if) ? (then)**\n- If-then-else: **(if) ? (then) : (else)**\n- Default: (value) **?: (defaultvalue)** \n\n#### 特殊操作\n\n- 无操作： _\n\n### 设置属性值-th:attr\n\n- 设置单个值\n\n```html\n<form action=\"subscribe.html\" th:attr=\"action=@{/subscribe}\">\n  <fieldset>\n    <input type=\"text\" name=\"email\" />\n    <input type=\"submit\" value=\"Subscribe!\" th:attr=\"value=#{subscribe.submit}\"/>\n  </fieldset>\n</form>\n```\n\n- 设置多个值\n\n```html\n<img src=\"../../images/gtvglogo.png\"  \n     th:attr=\"src=@{/images/gtvglogo.png},title=#{logo},alt=#{logo}\" />\n```\n\n[官方文档 - 5 Setting Attribute Values](https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html#setting-attribute-values)\n\n### 迭代\n\n```html\n<tr th:each=\"prod : ${prods}\">\n    <td th:text=\"${prod.name}\">Onions</td>\n    <td th:text=\"${prod.price}\">2.41</td>\n    <td th:text=\"${prod.inStock}? #{true} : #{false}\">yes</td>\n</tr>\n```\n\n```html\n<tr th:each=\"prod,iterStat : ${prods}\" th:class=\"${iterStat.odd}? \'odd\'\">\n    <td th:text=\"${prod.name}\">Onions</td>\n    <td th:text=\"${prod.price}\">2.41</td>\n    <td th:text=\"${prod.inStock}? #{true} : #{false}\">yes</td>\n</tr>\n```\n\n### 条件运算\n\n```html\n<a href=\"comments.html\"\n	th:href=\"@{/product/comments(prodId=${prod.id})}\"\n	th:if=\"${not #lists.isEmpty(prod.comments)}\">view</a>\n```\n\n```html\n<div th:switch=\"${user.role}\">\n      <p th:case=\"\'admin\'\">User is an administrator</p>\n      <p th:case=\"#{roles.manager}\">User is a manager</p>\n      <p th:case=\"*\">User is some other thing</p>\n</div>\n```\n\n### 属性优先级\n\n| Order | Feature                         | Attributes                                 |\n| :---- | :------------------------------ | :----------------------------------------- |\n| 1     | Fragment inclusion              | `th:insert` `th:replace`                   |\n| 2     | Fragment iteration              | `th:each`                                  |\n| 3     | Conditional evaluation          | `th:if` `th:unless` `th:switch` `th:case`  |\n| 4     | Local variable definition       | `th:object` `th:with`                      |\n| 5     | General attribute modification  | `th:attr` `th:attrprepend` `th:attrappend` |\n| 6     | Specific attribute modification | `th:value` `th:href` `th:src` `...`        |\n| 7     | Text (tag body modification)    | `th:text` `th:utext`                       |\n| 8     | Fragment specification          | `th:fragment`                              |\n| 9     | Fragment removal                | `th:remove`                                |\n\n[官方文档 - 10 Attribute Precedence](https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html#attribute-precedence)\n\n\n\n## 44、web实验-后台管理系统基本功能\n\n### 项目创建\n\n使用IDEA的Spring Initializr。\n\n- thymeleaf、\n- web-starter、\n- devtools、\n- lombok\n\n### 登陆页面\n\n- `/static` 放置 css，js等静态资源\n\n- `/templates/login.html` 登录页\n\n```html\n<html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"><!-- 要加这玩意thymeleaf才能用 -->\n\n<form class=\"form-signin\" action=\"index.html\" method=\"post\" th:action=\"@{/login}\">\n\n    ...\n    \n    <!-- 消息提醒 -->\n    <label style=\"color: red\" th:text=\"${msg}\"></label>\n    \n    <input type=\"text\" name=\"userName\" class=\"form-control\" placeholder=\"User ID\" autofocus>\n    <input type=\"password\" name=\"password\" class=\"form-control\" placeholder=\"Password\">\n    \n    <button class=\"btn btn-lg btn-login btn-block\" type=\"submit\">\n        <i class=\"fa fa-check\"></i>\n    </button>\n    \n    ...\n    \n</form>\n```\n\n- `/templates/main.html` 主页\n\nthymeleaf内联写法：\n\n```html\n<p>Hello, [[${session.user.name}]]!</p>\n```\n\n### 登录控制层\n\n```java\n@Controller\npublic class IndexController {\n    /**\n     * 来登录页\n     * @return\n     */\n    @GetMapping(value = {\"/\",\"/login\"})\n    public String loginPage(){\n\n        return \"login\";\n    }\n\n    @PostMapping(\"/login\")\n    public String main(User user, HttpSession session, Model model){ //RedirectAttributes\n\n        if(StringUtils.hasLength(user.getUserName()) && \"123456\".equals(user.getPassword())){\n            //把登陆成功的用户保存起来\n            session.setAttribute(\"loginUser\",user);\n            //登录成功重定向到main.html;  重定向防止表单重复提交\n            return \"redirect:/main.html\";\n        }else {\n            model.addAttribute(\"msg\",\"账号密码错误\");\n            //回到登录页面\n            return \"login\";\n        }\n    }\n    \n     /**\n     * 去main页面\n     * @return\n     */\n    @GetMapping(\"/main.html\")\n    public String mainPage(HttpSession session, Model model){\n        \n        //最好用拦截器,过滤器\n        Object loginUser = session.getAttribute(\"loginUser\");\n        if(loginUser != null){\n        	return \"main\";\n        }else {\n            //session过期，没有登陆过\n        	//回到登录页面\n	        model.addAttribute(\"msg\",\"请重新登录\");\n    	    return \"login\";\n        }\n    }\n    \n}\n```\n\n\n\n### 模型\n\n```java\n@AllArgsConstructor\n@NoArgsConstructor\n@Data\npublic class User {\n    private String userName;\n    private String password;\n}\n```\n\n','2023-05-14 05:10:49',0),(25,2,'md文件图片不显示解决办法','md文件图片使用图床托管','在编写 Markdown格式文件时，插入图片需要使用特定的语法。常用的插入图片的语法如下：\n[![20230514152544.png](https://i.postimg.cc/mDgDRgxR/20230514152544.png)](https://postimg.cc/d7gvjvtS)\n![](https://z4a.net/images/2023/05/14/e7d0f3721d13bde9045b0e932f918333.png)\n其中，图片描述为图片的文字描述，图片链接地址为图片的URL地址。注意，图片链接地址需要使用绝对路径或相对路径。\n\n如果在编写Markdown文件时，插入了图片但是图片无法正常显示，可能是以下原因导致的：\n\n1.图片链接地址不正确，或者图片链接地址不存在。\n2.图片格式不受支持。Markdown支持的图片格式包括 PNG、JPG、JPEG、GIF 等。\n3.图片链接地址没有加引号。Markdown中的链接地址需要用引号括起来。\n4.Markdown编辑器不支持显示图片。有些 Markdown编辑器可能不支持显示图片，可以尝试更换编辑器。\n\n如果以上方法都不能解决问题，可以尝试上传图片到图片托管网站，然后将图片链接地址替换为托管网站的图片链接地址。\n\n这里推荐一个国内可以免费用的图床网站*https://z4a.net/*。','2023-05-14 10:29:11',0),(26,2,'sfeafae','feaeffae','efa','2023-05-14 15:52:22',0);

/*Table structure for table `m_user` */

DROP TABLE IF EXISTS `m_user`;

CREATE TABLE `m_user` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `username` varchar(64) DEFAULT NULL,
  `avatar` varchar(255) DEFAULT NULL,
  `email` varchar(64) DEFAULT NULL,
  `password` varchar(64) DEFAULT NULL,
  `status` int NOT NULL,
  `created` datetime DEFAULT NULL,
  `last_login` datetime DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `UK_USERNAME` (`username`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb3;

/*Data for the table `m_user` */

insert  into `m_user`(`id`,`username`,`avatar`,`email`,`password`,`status`,`created`,`last_login`) values (1,'阿金a','https://image-1300566513.cos.ap-guangzhou.myqcloud.com/upload/images/5a9f48118166308daba8b6da7e466aab.jpg',NULL,'e10adc3949ba59abbe56e057f20f883e',0,'2020-04-20 10:44:01',NULL),(2,'AJin','https://image-1300566513.cos.ap-guangzhou.myqcloud.com/upload/images/5a9f48118166308daba8b6da7e466aab.jpg','AJin2023@163.com','e10adc3949ba59abbe56e057f20f883e',0,'2023-05-11 00:28:16',NULL);

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;
